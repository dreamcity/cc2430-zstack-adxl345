###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    28/Dec/2012  16:37:38 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\Source\AXD.c                  #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\C #
#                          C2430DB\f8wCoord.cfg" (-DCPU32MHZ                  #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS           #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f     #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\CC24 #
#                          30DB\f8wConfig.cfg" (-DSECURE=0                    #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\Source\AXD.c" -D CC2430EB -D           #
#                          REFLECTOR -D ZTOOL_P1 -D AXD_COR -D MT_TASK -D     #
#                          xMT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -lC "C:\Texas  #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\CoordinatorEB\List\" -lA      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\CoordinatorEB\List\ #
#                          " --diag_suppress Pe001,Pa010 --diag_remark pe550  #
#                          -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\CoordinatorEB\Ob #
#                          j\" -e --require_prototypes -z9 --no_code_motion   #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\SOURCE\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\Drivers\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I  #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MT\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\HAL #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2430EB\" -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\OSA #
#                          L\INCLUDE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\AF\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\.. #
#                          \..\..\COMPONENTS\STACK\NWK\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\SEC\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\STACK\SYS\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\ZDO\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\ZMA #
#                          C\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\AXDApp\CC2430DB\..\..\..\..\ #
#                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\SER #
#                          VICES\SDATA\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \LOW_LEVEL\SRF03\SINGLE_CHIP\" -I "C:\Program      #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\CoordinatorEB\List\A #
#                          XD.lst                                             #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\CoordinatorEB\Obj\AX #
#                          D.r51                                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Samples\AXDApp\Source\AXD.c
      1          /**************************************************************************************************
      2            Filename:       AXD.c
      3            Revised:        $Date: 2007-10-27 17:16:54 -0700 (Sat, 27 Oct 2007) $
      4            Revision:       $Revision: 15793 $
      5          
      6            Description:    Generic Application (no Profile).
      7          
      8          
      9            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41            This application isn't intended to do anything useful, it is
     42            intended to be a simple example of an application's structure.
     43          
     44            This application sends "Hello World" to another "Generic"
     45            application every 15 seconds.  The application will also
     46            receive "Hello World" packets.
     47          
     48            The "Hello World" messages are sent/received as MSG type message.
     49          
     50            This applications doesn't have a profile, so it handles everything
     51            directly - itself.
     52          
     53            Key control:
     54              SW1:
     55              SW2:  initiates end device binding
     56              SW3:
     57              SW4:  initiates a match description request
     58          *********************************************************************/
     59          
     60          /*********************************************************************
     61           * INCLUDES
     62           */
     63          #include "OSAL.h"
     64          #include "AF.h"
     65          #include "ZDApp.h"
     66          #include "ZDObject.h"
     67          #include "ZDProfile.h"
     68          
     69          #include "AXD.h"
     70          #include "DebugTrace.h"
     71          
     72          #if !defined( WIN32 )
     73            #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     74          #endif
     75          
     76          /* HAL */
     77          #include "hal_lcd.h"
     78          #include "hal_led.h"
     79          #include "hal_key.h"
     80          #include "hal_uart.h"
     81          
     82          /*用户自己的头文件*/
     83          #include "adxl345.h"
     84          #include "readaxd.h"
     85          
     86          /*********************************************************************
     87           * MACROS
     88           */
     89          
     90          /*********************************************************************
     91           * CONSTANTS
     92           */
     93          #define ZB_USER_EVENTS                    0x00FF
     94          
     95          /*********************************************************************
     96           * TYPEDEFS
     97           */
     98          
     99          /*********************************************************************
    100           * GLOBAL VARIABLES
    101           */
    102          
    103          // This list should be filled with Application specific Cluster IDs.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    104          const cId_t AXD_ClusterList[AXD_MAX_CLUSTERS] =
   \                     AXD_ClusterList:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for AXD_ClusterList>`
   \   000002                REQUIRE __INIT_XDATA_I
    105          {
    106            AXD_CLUSTERID
    107          };
    108          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    109          const SimpleDescriptionFormat_t AXD_SimpleDesc =
   \                     AXD_SimpleDesc:
   \   000000                DS 12
   \   00000C                REQUIRE `?<Initializer for AXD_SimpleDesc>`
   \   00000C                REQUIRE __INIT_XDATA_I
    110          {
    111            AXD_ENDPOINT,              //  int Endpoint;
    112            AXD_PROFID,                //  uint16 AppProfId[2];
    113            AXD_DEVICEID,              //  uint16 AppDeviceId[2];
    114            AXD_DEVICE_VERSION,        //  int   AppDevVer:4;
    115            AXD_FLAGS,                 //  int   AppFlags:4;
    116            AXD_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    117            (cId_t *)AXD_ClusterList,  //  byte *pAppInClusterList;
    118            AXD_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    119            (cId_t *)AXD_ClusterList   //  byte *pAppInClusterList;
    120          };
    121          
    122          // This is the Endpoint/Interface description.  It is defined here, but
    123          // filled-in in AXD_Init().  Another way to go would be to fill
    124          // in the structure here and make it a "const" (in code space).  The
    125          // way it's defined in this sample app it is define in RAM.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    126          endPointDesc_t AXD_epDesc;
   \                     AXD_epDesc:
   \   000000                DS 6
   \   000006                REQUIRE __INIT_XDATA_Z
    127          
    128          /*********************************************************************
    129           * EXTERNAL VARIABLES
    130           */
    131          //char TEMP[8] = {0,0,0,0,0,0,0,0};
    132          /*********************************************************************
    133           * EXTERNAL FUNCTIONS
    134           */
    135          
    136          /*********************************************************************
    137           * LOCAL VARIABLES
    138           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    139          byte AXD_TaskID;   // Task ID for internal task/event processing
   \                     AXD_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    140                                    // This variable will be received when
    141                                    // AXD_Init() is called.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    142          devStates_t AXD_NwkState;
   \                     AXD_NwkState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    143          
    144          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    145          byte AXD_TransID;  // This is the unique message ID (counter)
   \                     AXD_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    146          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    147          afAddrType_t AXD_DstAddr;
   \                     AXD_DstAddr:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    148          
    149          /*********************************************************************
    150           * LOCAL FUNCTIONS
    151           */
    152          void AXD_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg );
    153          void AXD_HandleKeys( byte shift, byte keys );
    154          void AXD_MessageMSGCB( afIncomingMSGPacket_t *pckt );
    155          void AXD_SendTheMessage( void );
    156          
    157          /*********************************************************************
    158           * NETWORK LAYER CALLBACKS
    159           */
    160          
    161          /*********************************************************************
    162           * PUBLIC FUNCTIONS
    163           */
    164          
    165          /*********************************************************************
    166           * @fn      AXD_Init
    167           *
    168           * @brief   Initialization function for the Generic App Task.
    169           *          This is called during initialization and should contain
    170           *          any application specific initialization (ie. hardware
    171           *          initialization/setup, table initialization, power up
    172           *          notificaiton ... ).
    173           *
    174           * @param   task_id - the ID assigned by OSAL.  This ID should be
    175           *                    used to send messages and set timers.
    176           *
    177           * @return  none
    178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    179          void AXD_Init( byte task_id )
   \                     AXD_Init:
    180          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    181            AXD_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#AXD_TaskID
   \   000008   F0           MOVX    @DPTR,A
    182            AXD_NwkState = DEV_INIT;
   \   000009   7401         MOV     A,#0x1
   \   00000B   90....       MOV     DPTR,#AXD_NwkState
   \   00000E   F0           MOVX    @DPTR,A
    183            AXD_TransID = 0;
   \   00000F   E4           CLR     A
   \   000010   90....       MOV     DPTR,#AXD_TransID
   \   000013   F0           MOVX    @DPTR,A
    184          
    185            // Device hardware initialization can be added here or in main() (Zmain.c).
    186            // If the hardware is application specific - add it here.
    187            // If the hardware is other parts of the device add it in main().
    188          
    189            AXD_DstAddr.addrMode = (afAddrMode_t)AddrNotPresent;
   \   000014   90....       MOV     DPTR,#(AXD_DstAddr + 2)
   \   000017   F0           MOVX    @DPTR,A
    190            AXD_DstAddr.endPoint = 0;
   \   000018   90....       MOV     DPTR,#(AXD_DstAddr + 3)
   \   00001B   F0           MOVX    @DPTR,A
    191            AXD_DstAddr.addr.shortAddr = 0;
   \   00001C   90....       MOV     DPTR,#AXD_DstAddr
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   F0           MOVX    @DPTR,A
    192          
    193            // Fill out the endpoint description.
    194            AXD_epDesc.endPoint = AXD_ENDPOINT;
   \   000022   740A         MOV     A,#0xa
   \   000024   90....       MOV     DPTR,#AXD_epDesc
   \   000027   F0           MOVX    @DPTR,A
    195            AXD_epDesc.task_id = &AXD_TaskID;
   \   000028   90....       MOV     DPTR,#(AXD_epDesc + 1)
   \   00002B   74..         MOV     A,#(AXD_TaskID & 0xff)
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   74..         MOV     A,#((AXD_TaskID >> 8) & 0xff)
   \   000031   F0           MOVX    @DPTR,A
    196            AXD_epDesc.simpleDesc
    197                      = (SimpleDescriptionFormat_t *)&AXD_SimpleDesc;
   \   000032   90....       MOV     DPTR,#(AXD_epDesc + 3)
   \   000035   74..         MOV     A,#(AXD_SimpleDesc & 0xff)
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   74..         MOV     A,#((AXD_SimpleDesc >> 8) & 0xff)
   \   00003B   F0           MOVX    @DPTR,A
    198            AXD_epDesc.latencyReq = noLatencyReqs;
   \   00003C   E4           CLR     A
   \   00003D   90....       MOV     DPTR,#(AXD_epDesc + 5)
   \   000040   F0           MOVX    @DPTR,A
    199          
    200            // Register the endpoint description with the AF
    201            afRegister( &AXD_epDesc );
   \   000041                ; Setup parameters for call to function afRegister
   \   000041   7A..         MOV     R2,#(AXD_epDesc & 0xff)
   \   000043   7B..         MOV     R3,#((AXD_epDesc >> 8) & 0xff)
   \   000045   12....       LCALL   ??afRegister?relay
    202          
    203            // Register for all key events - This app will handle all key events
    204            RegisterForKeys( AXD_TaskID );
   \   000048                ; Setup parameters for call to function RegisterForKeys
   \   000048   90....       MOV     DPTR,#AXD_TaskID
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F9           MOV     R1,A
   \   00004D   12....       LCALL   ??RegisterForKeys?relay
    205          
    206            // Update the display
    207          #if defined ( LCD_SUPPORTED )
    208              HalLcdWriteString( "AXD", HAL_LCD_LINE_1 );
   \   000050                ; Setup parameters for call to function HalLcdWriteString
   \   000050   7900         MOV     R1,#0x0
   \   000052   7A..         MOV     R2,#(`?<Constant "AXD">` & 0xff)
   \   000054   7B..         MOV     R3,#((`?<Constant "AXD">` >> 8) & 0xff)
   \   000056   12....       LCALL   ??HalLcdWriteString?relay
    209          #endif
    210          
    211            ZDO_RegisterForZDOMsg( AXD_TaskID, End_Device_Bind_rsp );
   \   000059                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000059   7A20         MOV     R2,#0x20
   \   00005B   7B80         MOV     R3,#-0x80
   \   00005D   90....       MOV     DPTR,#AXD_TaskID
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F9           MOV     R1,A
   \   000062   12....       LCALL   ??ZDO_RegisterForZDOMsg?relay
    212            ZDO_RegisterForZDOMsg( AXD_TaskID, Match_Desc_rsp );
   \   000065                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000065   7A06         MOV     R2,#0x6
   \   000067   7B80         MOV     R3,#-0x80
   \   000069   90....       MOV     DPTR,#AXD_TaskID
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F9           MOV     R1,A
   \   00006E   12....       LCALL   ??ZDO_RegisterForZDOMsg?relay
    213            
    214            //下面是用户自定义的初始化
    215            INT8U devid;
    216            P0DIR |= 0x18;
   \   000071   43FD18       ORL     0xfd,#0x18
   \   000074   E5FD         MOV     A,0xfd
    217            Init_ADXL345();
   \   000076                ; Setup parameters for call to function Init_ADXL345
   \   000076   12....       LCALL   ??Init_ADXL345?relay
    218            devid = Single_Read_ADXL345(0x00);
   \   000079                ; Setup parameters for call to function Single_Read_ADXL345
   \   000079   7900         MOV     R1,#0x0
   \   00007B   12....       LCALL   ??Single_Read_ADXL345?relay
    219          }
   \   00007E   02....       LJMP    ??Subroutine2_0 & 0xFFFF
   \   000081                REQUIRE P0DIR

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   7402         MOV     A,#0x2
   \   000006   12....       LCALL   ?XSTACK_DISP0_8
   \   000009   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??Subroutine2_0:
   \   00000C   D083         POP     DPH
   \   00000E   D082         POP     DPL
   \   000010   02....       LJMP    ?BRET
    220          
    221          /*********************************************************************
    222           * @fn      AXD_ProcessEvent
    223           *
    224           * @brief   Generic Application Task event processor.  This function
    225           *          is called to process all events for the task.  Events
    226           *          include timers, messages and any other user defined events.
    227           *
    228           * @param   task_id  - The OSAL assigned task ID.
    229           * @param   events - events to process.  This is a bit map and can
    230           *                   contain more than one event.
    231           *
    232           * @return  none
    233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    234          UINT16 AXD_ProcessEvent( byte task_id, UINT16 events )
   \                     AXD_ProcessEvent:
    235          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    236            afIncomingMSGPacket_t *MSGpkt;
    237          //  osal_event_hdr_t *pMsg;
    238            afDataConfirm_t *afDataConfirm;
    239          
    240            // Data Confirmation message fields
    241            byte sentEP;
    242            ZStatus_t sentStatus;
    243            byte sentTransID;       // This should match the value sent
    244          
    245            if ( events & SYS_EVENT_MSG )
   \   000009   7480         MOV     A,#-0x80
   \   00000B   5F           ANL     A,R7
   \   00000C   F9           MOV     R1,A
   \   00000D   E4           CLR     A
   \   00000E   7001         JNZ     ??AXD_ProcessEvent_0
   \   000010   E9           MOV     A,R1
   \                     ??AXD_ProcessEvent_0:
   \   000011   7003         JNZ     $+5
   \   000013   02....       LJMP    ??AXD_ProcessEvent_1 & 0xFFFF
    246            {
    247              MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( AXD_TaskID );
   \   000016                ; Setup parameters for call to function osal_msg_receive
   \   000016   8031         SJMP    ??AXD_ProcessEvent_2
    248              while ( MSGpkt )
    249              {
    250                switch ( MSGpkt->hdr.event )
    251                {
    252                  case ZDO_CB_MSG:
    253                    AXD_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );
    254                    break;
    255          
    256                  case KEY_CHANGE:
    257                    AXD_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    258                    break;
    259          
    260                  case AF_DATA_CONFIRM_CMD:
    261                    // This message is received as a confirmation of a data packet sent.
    262                    // The status is of ZStatus_t type [defined in ZComDef.h]
    263                    // The message fields are defined in AF.h
    264                    afDataConfirm = (afDataConfirm_t *)MSGpkt;
    265                    sentEP = afDataConfirm->endpoint;
    266                    sentStatus = afDataConfirm->hdr.status;
    267                    sentTransID = afDataConfirm->transID;
    268                    (void)sentEP;
    269                    (void)sentTransID;
    270          
    271                    // Action taken when confirmation is received.
    272                    if ( sentStatus != ZSuccess )
    273                    {
    274                      // The data wasn't delivered -- Do something
    275                    }
    276                    break;
    277          
    278                  case AF_INCOMING_MSG_CMD:
    279              //      MSGpkt = (afIncomingMSGPacket_t *) pMsg;
    280          #ifdef AXD_COR
    281                    AXD_ReceiveDataIndication( MSGpkt->srcAddr.addr.shortAddr, MSGpkt->clusterId,
    282                                              MSGpkt->cmd.DataLength, MSGpkt->cmd.Data);
    283                    //AXD_MessageMSGCB( MSGpkt );
    284          #endif
    285                    break;
    286          
    287                  case ZDO_STATE_CHANGE:
    288                    AXD_NwkState = (devStates_t)(MSGpkt->hdr.status);
   \                     ??AXD_ProcessEvent_3:
   \   000018   85..82       MOV     DPL,?V0 + 0
   \   00001B   85..83       MOV     DPH,?V0 + 1
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   90....       MOV     DPTR,#AXD_NwkState
   \   000023   F0           MOVX    @DPTR,A
    289                    if ( (AXD_NwkState == DEV_ZB_COORD)
    290                        || (AXD_NwkState == DEV_ROUTER)
    291                        || (AXD_NwkState == DEV_END_DEVICE) )
   \   000024   6409         XRL     A,#0x9
   \   000026   600A         JZ      ??AXD_ProcessEvent_4
   \   000028   E0           MOVX    A,@DPTR
   \   000029   6407         XRL     A,#0x7
   \   00002B   6005         JZ      ??AXD_ProcessEvent_4
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6406         XRL     A,#0x6
   \   000030   7010         JNZ     ??AXD_ProcessEvent_5
    292                    {
    293                      // Start sending "the" message in a regular interval.
    294                      osal_start_timerEx( AXD_TaskID,
    295                                          AXD_SEND_MSG_EVT,
    296                                          AXD_SEND_MSG_TIMEOUT );
   \                     ??AXD_ProcessEvent_4:
   \   000032                ; Setup parameters for call to function osal_start_timerEx
   \   000032   7C88         MOV     R4,#-0x78
   \   000034   7D13         MOV     R5,#0x13
   \   000036   7A01         MOV     R2,#0x1
   \   000038   7B00         MOV     R3,#0x0
   \   00003A   90....       MOV     DPTR,#AXD_TaskID
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F9           MOV     R1,A
   \   00003F   12....       LCALL   ??osal_start_timerEx?relay
    297                    }
    298                    break;
    299          
    300                  default:
    301                    break;
    302                }
    303          
    304                // Release the memory
    305                osal_msg_deallocate( (uint8 *)MSGpkt );
   \                     ??AXD_ProcessEvent_5:
   \   000042                ; Setup parameters for call to function osal_msg_deallocate
   \   000042   AA..         MOV     R2,?V0 + 0
   \   000044   AB..         MOV     R3,?V0 + 1
   \   000046   12....       LCALL   ??osal_msg_deallocate?relay
    306          
    307                // Next
    308                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( AXD_TaskID );
   \   000049                ; Setup parameters for call to function osal_msg_receive
   \                     ??AXD_ProcessEvent_2:
   \   000049   90....       MOV     DPTR,#AXD_TaskID
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   12....       LCALL   ??osal_msg_receive?relay
   \   000051   8A..         MOV     ?V0 + 0,R2
   \   000053   8B..         MOV     ?V0 + 1,R3
   \   000055   E5..         MOV     A,?V0 + 0
   \   000057   7002         JNZ     ??AXD_ProcessEvent_6
   \   000059   E5..         MOV     A,?V0 + 1
   \                     ??AXD_ProcessEvent_6:
   \   00005B   604E         JZ      ??AXD_ProcessEvent_7
   \   00005D   85..82       MOV     DPL,?V0 + 0
   \   000060   85..83       MOV     DPH,?V0 + 1
   \   000063   E0           MOVX    A,@DPTR
   \   000064   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for AXD_ProcessEvent>_0`:
   \   000067   00           DB        0
   \   000068   04           DB        4
   \   000069   1A           DB        26
   \   00006A   ....         DW        ??AXD_ProcessEvent_8
   \   00006C   C0           DB        192
   \   00006D   ....         DW        ??AXD_ProcessEvent_9
   \   00006F   D1           DB        209
   \   000070   ....         DW        ??AXD_ProcessEvent_3
   \   000072   D3           DB        211
   \   000073   ....         DW        ??AXD_ProcessEvent_10
   \   000075   ....         DW        ??AXD_ProcessEvent_5
   \                     ??AXD_ProcessEvent_10:
   \   000077                ; Setup parameters for call to function AXD_ProcessZDOMsgs
   \   000077   AA..         MOV     R2,?V0 + 0
   \   000079   AB..         MOV     R3,?V0 + 1
   \   00007B   12....       LCALL   ??AXD_ProcessZDOMsgs?relay
   \   00007E   80C2         SJMP    ??AXD_ProcessEvent_5
   \                     ??AXD_ProcessEvent_9:
   \   000080                ; Setup parameters for call to function AXD_HandleKeys
   \   000080   85..82       MOV     DPL,?V0 + 0
   \   000083   85..83       MOV     DPH,?V0 + 1
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   FA           MOV     R2,A
   \   00008B   85..82       MOV     DPL,?V0 + 0
   \   00008E   85..83       MOV     DPH,?V0 + 1
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   E0           MOVX    A,@DPTR
   \   000094   F9           MOV     R1,A
   \   000095   12....       LCALL   ??AXD_HandleKeys?relay
   \   000098   80A8         SJMP    ??AXD_ProcessEvent_5
   \                     ??AXD_ProcessEvent_8:
   \   00009A                ; Setup parameters for call to function displayXYZ
   \   00009A   E5..         MOV     A,?V0 + 0
   \   00009C   2415         ADD     A,#0x15
   \   00009E   F582         MOV     DPL,A
   \   0000A0   E5..         MOV     A,?V0 + 1
   \   0000A2   3400         ADDC    A,#0x0
   \   0000A4   F583         MOV     DPH,A
   \   0000A6   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000A9   8097         SJMP    ??AXD_ProcessEvent_5
    309              }
    310          
    311              // return unprocessed events
    312              return (events ^ SYS_EVENT_MSG);
   \                     ??AXD_ProcessEvent_7:
   \   0000AB   EE           MOV     A,R6
   \   0000AC   FA           MOV     R2,A
   \   0000AD   7480         MOV     A,#-0x80
   \   0000AF   6F           XRL     A,R7
   \                     ??AXD_ProcessEvent_11:
   \   0000B0   FB           MOV     R3,A
   \   0000B1   8028         SJMP    ??AXD_ProcessEvent_12
    313            }
    314          
    315            // Send a message out - This event is generated by a timer
    316            //  (setup in AXD_Init()).
    317            if ( events & AXD_SEND_MSG_EVT )
   \                     ??AXD_ProcessEvent_1:
   \   0000B3   EE           MOV     A,R6
   \   0000B4   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000B6   501A         JNC     ??AXD_ProcessEvent_13
    318            {
    319              // Send "the" message
    320            //  HalLcdWriteString( "SampleApp", HAL_LCD_LINE_1 );
    321              zb_HandleOsalEvent(events);
   \   0000B8                ; Setup parameters for call to function zb_HandleOsalEvent
   \   0000B8   12....       LCALL   ??zb_HandleOsalEvent?relay
    322              AXD_SendTheMessage();
    323          
    324              // Setup to send message again
    325              osal_start_timerEx( AXD_TaskID,
    326                                  AXD_SEND_MSG_EVT,
    327                                  AXD_SEND_MSG_TIMEOUT );
   \   0000BB                ; Setup parameters for call to function osal_start_timerEx
   \   0000BB   7C88         MOV     R4,#-0x78
   \   0000BD   7D13         MOV     R5,#0x13
   \   0000BF   7A01         MOV     R2,#0x1
   \   0000C1   7B00         MOV     R3,#0x0
   \   0000C3   90....       MOV     DPTR,#AXD_TaskID
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   F9           MOV     R1,A
   \   0000C8   12....       LCALL   ??osal_start_timerEx?relay
    328          
    329              // return unprocessed events
    330              return (events ^ AXD_SEND_MSG_EVT);
   \   0000CB   7401         MOV     A,#0x1
   \   0000CD   6E           XRL     A,R6
   \   0000CE   FA           MOV     R2,A
   \   0000CF   EF           MOV     A,R7
   \   0000D0   80DE         SJMP    ??AXD_ProcessEvent_11
    331            }
    332              if ( events & ( ZB_USER_EVENTS ) )
   \                     ??AXD_ProcessEvent_13:
   \   0000D2   6003         JZ      ??AXD_ProcessEvent_14
    333            {
    334              // User events are passed to the application
    335              zb_HandleOsalEvent( events );
   \   0000D4                ; Setup parameters for call to function zb_HandleOsalEvent
   \   0000D4   12....       LCALL   ??zb_HandleOsalEvent?relay
    336          
    337              // Do not return here, return 0 later
    338            }
    339          
    340            // Discard unknown events
    341            return 0;
   \                     ??AXD_ProcessEvent_14:
   \   0000D7   7A00         MOV     R2,#0x0
   \   0000D9   7B00         MOV     R3,#0x0
   \                     ??AXD_ProcessEvent_12:
   \   0000DB   7F04         MOV     R7,#0x4
   \   0000DD   02....       LJMP    ?BANKED_LEAVE_XDATA
    342          }
    343          
    344          /*********************************************************************
    345           * Event Generation Functions
    346           */
    347          /*********************************************************************
    348           * @fn      AXD_ProcessZDOMsgs()
    349           *
    350           * @brief   Process response messages
    351           *
    352           * @param   none
    353           *
    354           * @return  none
    355           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    356          void AXD_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg )
   \                     AXD_ProcessZDOMsgs:
    357          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    358            switch ( inMsg->clusterID )
   \   000005   EA           MOV     A,R2
   \   000006   240C         ADD     A,#0xc
   \   000008   F582         MOV     DPL,A
   \   00000A   EB           MOV     A,R3
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F583         MOV     DPH,A
   \   00000F   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000012   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for AXD_ProcessZDOMsgs>_0`:
   \   000015   0000         DW        0
   \   000017   0200         DW        2
   \   000019   0680         DW        32774
   \   00001B   ....         DW        ??AXD_ProcessZDOMsgs_0
   \   00001D   2080         DW        32800
   \   00001F   ....         DW        ??AXD_ProcessZDOMsgs_1
   \   000021   ....         DW        ??AXD_ProcessZDOMsgs_2
    359            {
    360              case End_Device_Bind_rsp:
    361                if ( ZDO_ParseBindRsp( inMsg ) == ZSuccess )
   \                     ??AXD_ProcessZDOMsgs_1:
   \   000023   EA           MOV     A,R2
   \   000024   2411         ADD     A,#0x11
   \   000026   F582         MOV     DPL,A
   \   000028   EB           MOV     A,R3
   \   000029   3400         ADDC    A,#0x0
   \   00002B   F583         MOV     DPH,A
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F8           MOV     R0,A
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F583         MOV     DPH,A
   \   000033   8882         MOV     DPL,R0
   \   000035   E0           MOVX    A,@DPTR
   \   000036   7009         JNZ     ??AXD_ProcessZDOMsgs_3
    362                {
    363                  // Light LED
    364                  HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   000038                ; Setup parameters for call to function HalLedSet
   \   000038   7A01         MOV     R2,#0x1
   \                     ??AXD_ProcessZDOMsgs_4:
   \   00003A   7908         MOV     R1,#0x8
   \   00003C   12....       LCALL   ??HalLedSet?relay
   \   00003F   8055         SJMP    ??AXD_ProcessZDOMsgs_2
    365                }
    366          #if defined(BLINK_LEDS)
    367                else
    368                {
    369                  // Flash LED to show failure
    370                  HalLedSet ( HAL_LED_4, HAL_LED_MODE_FLASH );
   \                     ??AXD_ProcessZDOMsgs_3:
   \   000041                ; Setup parameters for call to function HalLedSet
   \   000041   7A04         MOV     R2,#0x4
   \   000043   80F5         SJMP    ??AXD_ProcessZDOMsgs_4
    371                }
    372          #endif
    373                break;
    374          
    375              case Match_Desc_rsp:
    376                {
    377                  ZDO_ActiveEndpointRsp_t *pRsp = ZDO_ParseEPListRsp( inMsg );
   \                     ??AXD_ProcessZDOMsgs_0:
   \   000045                ; Setup parameters for call to function ZDO_ParseEPListRsp
   \   000045   12....       LCALL   ??ZDO_ParseEPListRsp?relay
   \   000048   8A..         MOV     ?V0 + 0,R2
   \   00004A   8B..         MOV     ?V0 + 1,R3
   \   00004C   AE..         MOV     R6,?V0 + 0
   \   00004E   AF..         MOV     R7,?V0 + 1
    378                  if ( pRsp )
   \   000050   EE           MOV     A,R6
   \   000051   7001         JNZ     ??AXD_ProcessZDOMsgs_5
   \   000053   EF           MOV     A,R7
   \                     ??AXD_ProcessZDOMsgs_5:
   \   000054   6040         JZ      ??AXD_ProcessZDOMsgs_2
    379                  {
    380                    if ( pRsp->status == ZSuccess && pRsp->cnt )
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   7032         JNZ     ??AXD_ProcessZDOMsgs_6
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   602C         JZ      ??AXD_ProcessZDOMsgs_6
    381                    {
    382                      AXD_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000063   7402         MOV     A,#0x2
   \   000065   90....       MOV     DPTR,#(AXD_DstAddr + 2)
   \   000068   F0           MOVX    @DPTR,A
    383                      AXD_DstAddr.addr.shortAddr = pRsp->nwkAddr;
   \   000069   8E82         MOV     DPL,R6
   \   00006B   8F83         MOV     DPH,R7
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F8           MOV     R0,A
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F9           MOV     R1,A
   \   000073   90....       MOV     DPTR,#AXD_DstAddr
   \   000076   E8           MOV     A,R0
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   E9           MOV     A,R1
   \   00007A   F0           MOVX    @DPTR,A
    384                      // Take the first endpoint, Can be changed to search through endpoints
    385                      AXD_DstAddr.endPoint = pRsp->epList[0];
   \   00007B   8E82         MOV     DPL,R6
   \   00007D   8F83         MOV     DPH,R7
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   90....       MOV     DPTR,#(AXD_DstAddr + 3)
   \   000087   F0           MOVX    @DPTR,A
    386          
    387                      // Light LED
    388                      HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   000088                ; Setup parameters for call to function HalLedSet
   \   000088   7A01         MOV     R2,#0x1
   \   00008A   7908         MOV     R1,#0x8
   \   00008C   12....       LCALL   ??HalLedSet?relay
    389                    }
    390                    osal_mem_free( pRsp );
   \                     ??AXD_ProcessZDOMsgs_6:
   \   00008F                ; Setup parameters for call to function osal_mem_free
   \   00008F   EE           MOV     A,R6
   \   000090   FA           MOV     R2,A
   \   000091   EF           MOV     A,R7
   \   000092   FB           MOV     R3,A
   \   000093   12....       LCALL   ??osal_mem_free?relay
    391                  }
    392                }
    393                break;
    394            }
    395          }
   \                     ??AXD_ProcessZDOMsgs_2:
   \   000096                REQUIRE ?Subroutine3
   \   000096                ; // Fall through to label ?Subroutine3

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   78..         MOV     R0,#?V0 + 0
   \   000009   22           RET
    396          
    397          /*********************************************************************
    398           * @fn      AXD_HandleKeys
    399           *
    400           * @brief   Handles all key events for this device.
    401           *
    402           * @param   shift - true if in shift/alt.
    403           * @param   keys - bit field for key events. Valid entries:
    404           *                 HAL_KEY_SW_4
    405           *                 HAL_KEY_SW_3
    406           *                 HAL_KEY_SW_2
    407           *                 HAL_KEY_SW_1
    408           *
    409           * @return  none
    410           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    411          void AXD_HandleKeys( byte shift, byte keys )
   \                     AXD_HandleKeys:
    412          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
    413            zAddrType_t dstAddr;
    414          
    415            // Shift is used to make each button/switch dual purpose.
    416            if ( shift )
   \   00000C   E9           MOV     A,R1
   \   00000D   6003         JZ      $+5
   \   00000F   02....       LJMP    ??AXD_HandleKeys_0 & 0xFFFF
    417            {
    418              if ( keys & HAL_KEY_SW_1 )
    419              {
    420              }
    421              if ( keys & HAL_KEY_SW_2 )
    422              {
    423              }
    424              if ( keys & HAL_KEY_SW_3 )
    425              {
    426              }
    427              if ( keys & HAL_KEY_SW_4 )
    428              {
    429              }
    430            }
    431            else
    432            {
    433              if ( keys & HAL_KEY_SW_1 )
    434              {
    435              }
    436          
    437              if ( keys & HAL_KEY_SW_2 )
   \   000012   EE           MOV     A,R6
   \   000013   A2E1         MOV     C,0xE0 /* A   */.1
   \   000015   5070         JNC     ??AXD_HandleKeys_1
    438              {
    439                HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \   000017                ; Setup parameters for call to function HalLedSet
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7908         MOV     R1,#0x8
   \   00001B   12....       LCALL   ??HalLedSet?relay
    440          
    441                // Initiate an End Device Bind Request for the mandatory endpoint
    442                dstAddr.addrMode = Addr16Bit;
   \   00001E   7408         MOV     A,#0x8
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   7402         MOV     A,#0x2
   \   000025   F0           MOVX    @DPTR,A
    443                dstAddr.addr.shortAddr = 0x0000; // Coordinator
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   E4           CLR     A
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   F0           MOVX    @DPTR,A
    444                ZDP_EndDeviceBindReq( &dstAddr, NLME_GetShortAddr(),
    445                                      AXD_epDesc.endPoint,
    446                                      AXD_PROFID,
    447                                      AXD_MAX_CLUSTERS, (cId_t *)AXD_ClusterList,
    448                                      AXD_MAX_CLUSTERS, (cId_t *)AXD_ClusterList,
    449                                      FALSE );
   \   000030                ; Setup parameters for call to function NLME_GetShortAddr
   \   000030   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000033   8A..         MOV     ?V0 + 0,R2
   \   000035   8B..         MOV     ?V0 + 1,R3
   \   000037   AC..         MOV     R4,?V0 + 0
   \   000039   AD..         MOV     R5,?V0 + 1
   \   00003B                ; Setup parameters for call to function ZDP_EndDeviceBindReq
   \   00003B   75..00       MOV     ?V0 + 0,#0x0
   \   00003E   78..         MOV     R0,#?V0 + 0
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000043   75....       MOV     ?V0 + 0,#(AXD_ClusterList & 0xff)
   \   000046   75....       MOV     ?V0 + 1,#((AXD_ClusterList >> 8) & 0xff)
   \   000049   78..         MOV     R0,#?V0 + 0
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   75..01       MOV     ?V0 + 0,#0x1
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000056   75....       MOV     ?V0 + 0,#(AXD_ClusterList & 0xff)
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005E   75..01       MOV     ?V0 + 0,#0x1
   \   000061   78..         MOV     R0,#?V0 + 0
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000066   75..04       MOV     ?V0 + 0,#0x4
   \   000069   75..0F       MOV     ?V0 + 1,#0xf
   \   00006C   78..         MOV     R0,#?V0 + 0
   \   00006E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000071   90....       MOV     DPTR,#AXD_epDesc
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F9           MOV     R1,A
   \   000076   7409         MOV     A,#0x9
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   AA82         MOV     R2,DPL
   \   00007D   AB83         MOV     R3,DPH
   \   00007F   12....       LCALL   ??ZDP_EndDeviceBindReq?relay
   \   000082   7409         MOV     A,#0x9
   \   000084   12....       LCALL   ?DEALLOC_XSTACK8
    450              }
    451          
    452              if ( keys & HAL_KEY_SW_3 )
    453              {
    454              }
    455          
    456              if ( keys & HAL_KEY_SW_4 )
   \                     ??AXD_HandleKeys_1:
   \   000087   EE           MOV     A,R6
   \   000088   A2E3         MOV     C,0xE0 /* A   */.3
   \   00008A   505F         JNC     ??AXD_HandleKeys_0
    457              {
    458                HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \   00008C                ; Setup parameters for call to function HalLedSet
   \   00008C   7A00         MOV     R2,#0x0
   \   00008E   7908         MOV     R1,#0x8
   \   000090   12....       LCALL   ??HalLedSet?relay
    459          
    460                // Initiate a Match Description Request (Service Discovery)
    461                dstAddr.addrMode = AddrBroadcast;
   \   000093   7408         MOV     A,#0x8
   \   000095   12....       LCALL   ?XSTACK_DISP0_8
   \   000098   740F         MOV     A,#0xf
   \   00009A   F0           MOVX    @DPTR,A
    462                dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
   \   00009B   85..82       MOV     DPL,?XSP + 0
   \   00009E   85..83       MOV     DPH,?XSP + 1
   \   0000A1   74FF         MOV     A,#-0x1
   \   0000A3   F0           MOVX    @DPTR,A
   \   0000A4   A3           INC     DPTR
   \   0000A5   F0           MOVX    @DPTR,A
    463                ZDP_MatchDescReq( &dstAddr, NWK_BROADCAST_SHORTADDR,
    464                                  AXD_PROFID,
    465                                  AXD_MAX_CLUSTERS, (cId_t *)AXD_ClusterList,
    466                                  AXD_MAX_CLUSTERS, (cId_t *)AXD_ClusterList,
    467                                  FALSE );
   \   0000A6                ; Setup parameters for call to function ZDP_MatchDescReq
   \   0000A6   75..00       MOV     ?V0 + 0,#0x0
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AE   75....       MOV     ?V0 + 0,#(AXD_ClusterList & 0xff)
   \   0000B1   75....       MOV     ?V0 + 1,#((AXD_ClusterList >> 8) & 0xff)
   \   0000B4   78..         MOV     R0,#?V0 + 0
   \   0000B6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B9   75..01       MOV     ?V0 + 0,#0x1
   \   0000BC   78..         MOV     R0,#?V0 + 0
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C1   75....       MOV     ?V0 + 0,#(AXD_ClusterList & 0xff)
   \   0000C4   78..         MOV     R0,#?V0 + 0
   \   0000C6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C9   75..04       MOV     ?V0 + 0,#0x4
   \   0000CC   75..0F       MOV     ?V0 + 1,#0xf
   \   0000CF   78..         MOV     R0,#?V0 + 0
   \   0000D1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D4   7901         MOV     R1,#0x1
   \   0000D6   7CFF         MOV     R4,#-0x1
   \   0000D8   7DFF         MOV     R5,#-0x1
   \   0000DA   7408         MOV     A,#0x8
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   AA82         MOV     R2,DPL
   \   0000E1   AB83         MOV     R3,DPH
   \   0000E3   12....       LCALL   ??ZDP_MatchDescReq?relay
   \   0000E6   7408         MOV     A,#0x8
   \   0000E8   12....       LCALL   ?DEALLOC_XSTACK8
    468              }
    469            }
    470          }
   \                     ??AXD_HandleKeys_0:
   \   0000EB   7409         MOV     A,#0x9
   \   0000ED   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F0   02....       LJMP    ?Subroutine3 & 0xFFFF
    471          
    472          /*********************************************************************
    473           * LOCAL FUNCTIONS
    474           */
    475          
    476          /*********************************************************************
    477           * @fn      AXD_MessageMSGCB
    478           *
    479           * @brief   Data message processor callback.  This function processes
    480           *          any incoming data - probably from other devices.  So, based
    481           *          on cluster ID, perform the intended action.
    482           *
    483           * @param   none
    484           *
    485           * @return  none
    486           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    487          void AXD_MessageMSGCB( afIncomingMSGPacket_t *pkt )
   \                     AXD_MessageMSGCB:
    488          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    489            switch ( pkt->clusterId )
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000010   12....       LCALL   ?US_SWITCH_DENSE
   \                     `?<Jumptable for AXD_MessageMSGCB>_0`:
   \   000013   0100         DW        1
   \   000015   00           DB        0
   \   000016   ....         DW        ??AXD_MessageMSGCB_0
   \   000018   ....         DW        ??AXD_MessageMSGCB_1
    490            {
    491              case AXD_CLUSTERID:
    492                // "the" message
    493          #if defined( LCD_SUPPORTED )
    494                HalLcdWriteScreen( (char*)pkt->cmd.Data, "rcvd" );
   \                     ??AXD_MessageMSGCB_1:
   \   00001A                ; Setup parameters for call to function HalLcdWriteScreen
   \   00001A   7C..         MOV     R4,#(`?<Constant "rcvd">` & 0xff)
   \   00001C   7D..         MOV     R5,#((`?<Constant "rcvd">` >> 8) & 0xff)
   \   00001E   EA           MOV     A,R2
   \   00001F   2415         ADD     A,#0x15
   \   000021   F582         MOV     DPL,A
   \   000023   EB           MOV     A,R3
   \   000024   3400         ADDC    A,#0x0
   \   000026   F583         MOV     DPH,A
   \   000028   E0           MOVX    A,@DPTR
   \   000029   FA           MOV     R2,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   FB           MOV     R3,A
   \   00002D   12....       LCALL   ??HalLcdWriteScreen?relay
    495          #elif defined( WIN32 )
    496                WPRINTSTR( pkt->cmd.Data );
    497          #endif
    498                break;
    499            }
    500          }
   \                     ??AXD_MessageMSGCB_0:
   \   000030   02....       LJMP    ?Subroutine3 & 0xFFFF
    501          
    502          /*********************************************************************
    503           * @fn      AXD_SendTheMessage
    504           *
    505           * @brief   Send "the" message.
    506           *
    507           * @param   none
    508           *
    509           * @return  none
    510           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    511          void AXD_SendTheMessage( void )
   \                     AXD_SendTheMessage:
    512          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    513          //  char theMessageData[] = "Hello World";
    514          #ifdef AXD_END
    515          //  int i;
    516          
    517          //  for(i=0;i<8;i++)
    518          //  {
    519          //    TEMP[i]++;
    520          //  }
    521            char *TEMP;
    522            TEMP = Multiple_Read_ADXL345();
    523            displayXYZ(TEMP);
    524          
    525            if ( AF_DataRequest( &AXD_DstAddr, &AXD_epDesc,
    526                                 AXD_CLUSTERID,
    527                                 (byte)9,
    528                                 (byte *)(TEMP),
    529                                 &AXD_TransID,
    530                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
    531            {
    532              // Successfully requested to be sent.
    533            }
    534            else
    535            {
    536              // Error occurred in request to send.
    537            }
    538          #endif
    539          }
   \   000000   02....       LJMP    ?BRET
    540          
    541          /*********************************************************************
    542          *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    543          void AXD_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
   \                     AXD_ReceiveDataIndication:
   \   000000                REQUIRE ?Subroutine2
   \   000000                ; // Fall through to label ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005                ; Setup parameters for call to function displayXYZ
   \   000005                ; Setup parameters for call to function displayXYZ
   \   000005   12....       LCALL   ??displayXYZ?relay
   \   000008   22           RET
    544          {
    545          #if defined ( MT_SAPI_CB_FUNC )
    546            /* First check if MT has subscribed for this callback. If so , pass it as
    547            a event to MonitorTest and return control to calling function after that */
    548            if ( SAPICB_CHECK( SPI_CB_SAPI_RCV_DATA_IND ) )
    549            {
    550              zb_MTCallbackReceiveDataIndication( source, command, len, pData  );
    551            }
    552            else
    553          #endif  //MT_SAPI_CB_FUNC
    554            {
    555              zb_ReceiveDataIndication( source, command, len, pData  );
    556            }
    557          }
    558          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    559          void zb_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
   \                     zb_ReceiveDataIndication:
   \   000000   80..         SJMP    ?Subroutine2

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "AXD">>`:
   \   000000   41584400     DB "AXD"

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "rcvd">>`:
   \   000000   72637664     DB "rcvd"
   \            00      

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for AXD_ClusterList>`:
   \   000000   0100         DW 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for AXD_SimpleDesc>`:
   \   000000   0A           DB 10
   \   000001   040F0100     DW 3844, 1
   \   000005   0001         DB 0, 1
   \   000007   ....         DW AXD_ClusterList
   \   000009   01           DB 1
   \   00000A   ....         DW AXD_ClusterList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_ProcessEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_ProcessEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_ProcessZDOMsgs?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_ProcessZDOMsgs

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_HandleKeys?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_MessageMSGCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_MessageMSGCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_SendTheMessage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_SendTheMessage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_ReceiveDataIndication?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_ReceiveDataIndication

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zb_ReceiveDataIndication?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_ReceiveDataIndication

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "AXD">`:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for <Constant "AXD">>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "rcvd">`:
   \   000000                DS 5
   \   000005                REQUIRE `?<Initializer for <Constant "rcvd">>`
   \   000005                REQUIRE __INIT_XDATA_I
    560          {
    561          //  uint8 buf[8];
    562            displayXYZ(pData);
                              ^
Warning[Pe167]: argument of type "uint8 *" is incompatible with parameter of
          type "char *"
    563          
    564              
    565          }

   Maximum stack usage in bytes:

     Function                   ISTACK PSTACK XSTACK
     --------                   ------ ------ ------
     AXD_HandleKeys                 1      0     40
       -> HalLedSet                 0      0     38
       -> NLME_GetShortAddr         0      0     38
       -> ZDP_EndDeviceBindReq      0      0     56
       -> HalLedSet                 0      0     38
       -> ZDP_MatchDescReq          0      0     54
     AXD_Init                       2      0      0
       -> afRegister                4      0      0
       -> RegisterForKeys           4      0      0
       -> HalLcdWriteString         4      0      0
       -> ZDO_RegisterForZDOMsg     4      0      0
       -> ZDO_RegisterForZDOMsg     4      0      0
       -> Init_ADXL345              4      0      0
       -> Single_Read_ADXL345       4      0      0
     AXD_MessageMSGCB               0      0     10
       -> HalLcdWriteScreen         0      0     20
     AXD_ProcessEvent               0      0     12
       -> osal_msg_receive          0      0     24
       -> osal_start_timerEx        0      0     24
       -> osal_msg_deallocate       0      0     24
       -> osal_msg_receive          0      0     24
       -> AXD_ProcessZDOMsgs        0      0     24
       -> AXD_HandleKeys            0      0     24
       -> displayXYZ                0      0     24
       -> zb_HandleOsalEvent        0      0     24
       -> osal_start_timerEx        0      0     24
       -> zb_HandleOsalEvent        0      0     24
     AXD_ProcessZDOMsgs             0      0     22
       -> HalLedSet                 0      0     20
       -> HalLedSet                 0      0     20
       -> ZDO_ParseEPListRsp        0      0     20
       -> HalLedSet                 0      0     20
       -> osal_mem_free             0      0     20
     AXD_ReceiveDataIndication      2      0      4
       -> displayXYZ                4      0      0
     AXD_SendTheMessage             0      0      0
     zb_ReceiveDataIndication       2      0      4
       -> displayXYZ                4      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     P0DIR                             1
     AXD_ClusterList                   2
     AXD_SimpleDesc                   12
     AXD_epDesc                        6
     AXD_TaskID                        1
     AXD_NwkState                      1
     AXD_TransID                       1
     AXD_DstAddr                       4
     AXD_Init                        129
     ?Subroutine2                     19
     AXD_ProcessEvent                224
     AXD_ProcessZDOMsgs              150
     ?Subroutine3                      5
     ?Subroutine1                     10
     AXD_HandleKeys                  243
     AXD_MessageMSGCB                 51
     AXD_SendTheMessage                3
     AXD_ReceiveDataIndication         0
     ?Subroutine0                      9
     zb_ReceiveDataIndication          2
     ?<Initializer for <Constant "AXD">>
                                       4
     ?<Initializer for <Constant "rcvd">>
                                       5
     ?<Initializer for AXD_ClusterList>
                                       2
     ?<Initializer for AXD_SimpleDesc>
                                      12
     ??AXD_Init?relay                  6
     ??AXD_ProcessEvent?relay          6
     ??AXD_ProcessZDOMsgs?relay        6
     ??AXD_HandleKeys?relay            6
     ??AXD_MessageMSGCB?relay          6
     ??AXD_SendTheMessage?relay        6
     ??AXD_ReceiveDataIndication?relay
                                       6
     ??zb_ReceiveDataIndication?relay
                                       6
     ?<Constant "AXD">                 4
     ?<Constant "rcvd">                5

 
 845 bytes in segment BANKED_CODE
  48 bytes in segment BANK_RELAYS
   1 byte  in segment SFR_AN
  23 bytes in segment XDATA_I
  23 bytes in segment XDATA_ID
  13 bytes in segment XDATA_Z
 
 916 bytes of CODE  memory
   0 bytes of DATA  memory (+ 1 byte shared)
  36 bytes of XDATA memory

Errors: none
Warnings: 1
