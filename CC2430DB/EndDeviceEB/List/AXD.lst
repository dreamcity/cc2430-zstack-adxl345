###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    10/Mar/2013  00:34:34 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\Source\AXD.c   #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\..\..\Tools\CC2430DB\f8wEndev.cfg" (-DCPU32MHZ   #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\Tools #
#                          \CC2430DB\f8wConfig.cfg" (-DSECURE=0               #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\Source\AXD.c" -D        #
#                          CC2430EB -D AXD_END -D NWK_AUTO_POLL -D REFLECTOR  #
#                          -D ZTOOL_P1 -D MT_TASK -D xMT_ZDO_FUNC -D          #
#                          LCD_SUPPORTED=DEBUG -D xPOWER_SAVING -lC           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345\CC2430DB\EndD #
#                          eviceEB\List\" -lA "C:\Texas                       #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\EndDeviceEB\Li #
#                          st\" --diag_suppress Pe001,Pa010 --diag_remark     #
#                          pe550 -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\ #
#                          Projects\zstack\Samples\cc2430-zstack-adxl345\CC24 #
#                          30DB\EndDeviceEB\Obj\" -e --require_prototypes     #
#                          -z2 --no_cse --no_unroll --no_inline               #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs 8  #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\" #
#                           -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proje #
#                          cts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\ #
#                          ..\SOURCE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\Drivers\"   #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\..\..\ZMAIN\TI2430DB\" -I "C:\Texas              #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MT\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\TARGET\CC2430EB\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\INCLUDE\" -I "C:\Texas            #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\AF\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\NWK\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SEC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SYS\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\ZDO\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\F8W\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\" -I "C:\Texas                    #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SADDR\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SDATA\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          4.0 Evaluation version\8051\INC\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\EndDe #
#                          viceEB\List\AXD.lst                                #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\EndDe #
#                          viceEB\Obj\AXD.r51                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Samples\cc2430-zstack-adxl345\Source\AXD.c
      1          /**************************************************************************************************
      2            Filename:       AXD.c
      3            Revised:        $Date: 2007-10-27 17:16:54 -0700 (Sat, 27 Oct 2007) $
      4            Revision:       $Revision: 15793 $
      5          
      6            Description:    Generic Application (no Profile).
      7          
      8          
      9            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41            This application isn't intended to do anything useful, it is
     42            intended to be a simple example of an application's structure.
     43          
     44            This application sends "Hello World" to another "Generic"
     45            application every 15 seconds.  The application will also
     46            receive "Hello World" packets.
     47          
     48            The "Hello World" messages are sent/received as MSG type message.
     49          
     50            This applications doesn't have a profile, so it handles everything
     51            directly - itself.
     52          
     53            Key control:
     54              SW1:
     55              SW2:  initiates end device binding
     56              SW3:
     57              SW4:  initiates a match description request
     58          *********************************************************************/
     59          
     60          /*********************************************************************
     61           * INCLUDES
     62           */
     63          #include "OSAL.h"
     64          #include "AF.h"
     65          #include "ZDApp.h"
     66          #include "ZDObject.h"
     67          #include "ZDProfile.h"
     68          
     69          #include "AXD.h"
     70          #include "DebugTrace.h"
     71          
     72          #if !defined( WIN32 )
     73            #include "OnBoard.h"
     74          #endif
     75          
     76          /* HAL */
     77          #include "hal_lcd.h"
     78          #include "hal_led.h"
     79          #include "hal_key.h"
     80          #include "hal_uart.h"
     81          
     82          /*用户自己的头文件*/
     83          #include "adxl345.h"
     84          #include "readaxd.h"
     85          
     86          /*********************************************************************
     87           * MACROS
     88           */
     89          
     90          /*********************************************************************
     91           * CONSTANTS
     92           */
     93          #define ZB_USER_EVENTS                    0x00FF
     94          
     95          /*********************************************************************
     96           * TYPEDEFS
     97           */
     98          
     99          /*********************************************************************
    100           * GLOBAL VARIABLES
    101           */
    102          
    103          // This list should be filled with Application specific Cluster IDs.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    104          const cId_t AXD_ClusterList[AXD_MAX_CLUSTERS] =
   \                     AXD_ClusterList:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for AXD_ClusterList>`
   \   000002                REQUIRE __INIT_XDATA_I
    105          {
    106            AXD_CLUSTERID
    107          };
    108          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    109          const SimpleDescriptionFormat_t AXD_SimpleDesc =
   \                     AXD_SimpleDesc:
   \   000000                DS 12
   \   00000C                REQUIRE `?<Initializer for AXD_SimpleDesc>`
   \   00000C                REQUIRE __INIT_XDATA_I
    110          {
    111            AXD_ENDPOINT,              //  int Endpoint;
    112            AXD_PROFID,                //  uint16 AppProfId[2];
    113            AXD_DEVICEID,              //  uint16 AppDeviceId[2];
    114            AXD_DEVICE_VERSION,        //  int   AppDevVer:4;
    115            AXD_FLAGS,                 //  int   AppFlags:4;
    116            AXD_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    117            (cId_t *)AXD_ClusterList,  //  byte *pAppInClusterList;
    118            AXD_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    119            (cId_t *)AXD_ClusterList   //  byte *pAppInClusterList;
    120          };
    121          
    122          // This is the Endpoint/Interface description.  It is defined here, but
    123          // filled-in in AXD_Init().  Another way to go would be to fill
    124          // in the structure here and make it a "const" (in code space).  The
    125          // way it's defined in this sample app it is define in RAM.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    126          endPointDesc_t AXD_epDesc;
   \                     AXD_epDesc:
   \   000000                DS 6
   \   000006                REQUIRE __INIT_XDATA_Z
    127          
    128          /*********************************************************************
    129           * EXTERNAL VARIABLES
    130           */
    131          //char TEMP[8] = {0,0,0,0,0,0,0,0};
    132          /*********************************************************************
    133           * EXTERNAL FUNCTIONS
    134           */
    135          
    136          /*********************************************************************
    137           * LOCAL VARIABLES
    138           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    139          byte AXD_TaskID;   // Task ID for internal task/event processing
   \                     AXD_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    140                                    // This variable will be received when
    141                                    // AXD_Init() is called.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    142          devStates_t AXD_NwkState;
   \                     AXD_NwkState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    143          
    144          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    145          byte AXD_TransID;  // This is the unique message ID (counter)
   \                     AXD_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    146          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    147          afAddrType_t AXD_DstAddr;
   \                     AXD_DstAddr:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    148          
    149          /*********************************************************************
    150           * LOCAL FUNCTIONS
    151           */
    152          void AXD_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg );
    153          void AXD_HandleKeys( byte shift, byte keys );
    154          void AXD_MessageMSGCB( afIncomingMSGPacket_t *pckt );
    155          void AXD_SendTheMessage( void );
    156          
    157          /*********************************************************************
    158           * NETWORK LAYER CALLBACKS
    159           */
    160          
    161          /*********************************************************************
    162           * PUBLIC FUNCTIONS
    163           */
    164          
    165          /*********************************************************************
    166           * @fn      AXD_Init
    167           *
    168           * @brief   Initialization function for the Generic App Task.
    169           *          This is called during initialization and should contain
    170           *          any application specific initialization (ie. hardware
    171           *          initialization/setup, table initialization, power up
    172           *          notificaiton ... ).
    173           *
    174           * @param   task_id - the ID assigned by OSAL.  This ID should be
    175           *                    used to send messages and set timers.
    176           *
    177           * @return  none
    178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    179          void AXD_Init( byte task_id )
   \                     AXD_Init:
    180          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    181            AXD_TaskID = task_id;
   \   000006   90....       MOV     DPTR,#AXD_TaskID
   \   000009   F0           MOVX    @DPTR,A
    182            AXD_NwkState = DEV_INIT;
   \   00000A   7401         MOV     A,#0x1
   \   00000C   90....       MOV     DPTR,#AXD_NwkState
   \   00000F   F0           MOVX    @DPTR,A
    183            AXD_TransID = 0;
   \   000010   7400         MOV     A,#0x0
   \   000012   90....       MOV     DPTR,#AXD_TransID
   \   000015   F0           MOVX    @DPTR,A
    184          
    185            // Device hardware initialization can be added here or in main() (Zmain.c).
    186            // If the hardware is application specific - add it here.
    187            // If the hardware is other parts of the device add it in main().
    188          
    189            AXD_DstAddr.addrMode = (afAddrMode_t)AddrNotPresent;
   \   000016   7400         MOV     A,#0x0
   \   000018   90....       MOV     DPTR,#(AXD_DstAddr + 2)
   \   00001B   F0           MOVX    @DPTR,A
    190            AXD_DstAddr.endPoint = 0;
   \   00001C   7400         MOV     A,#0x0
   \   00001E   90....       MOV     DPTR,#(AXD_DstAddr + 3)
   \   000021   F0           MOVX    @DPTR,A
    191            AXD_DstAddr.addr.shortAddr = 0;
   \   000022   90....       MOV     DPTR,#AXD_DstAddr
   \   000025   7400         MOV     A,#0x0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   7400         MOV     A,#0x0
   \   00002B   F0           MOVX    @DPTR,A
    192          
    193            // Fill out the endpoint description.
    194            AXD_epDesc.endPoint = AXD_ENDPOINT;
   \   00002C   740A         MOV     A,#0xa
   \   00002E   90....       MOV     DPTR,#AXD_epDesc
   \   000031   F0           MOVX    @DPTR,A
    195            AXD_epDesc.task_id = &AXD_TaskID;
   \   000032   90....       MOV     DPTR,#(AXD_epDesc + 1)
   \   000035   74..         MOV     A,#(AXD_TaskID & 0xff)
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   74..         MOV     A,#((AXD_TaskID >> 8) & 0xff)
   \   00003B   F0           MOVX    @DPTR,A
    196            AXD_epDesc.simpleDesc
    197                      = (SimpleDescriptionFormat_t *)&AXD_SimpleDesc;
   \   00003C   90....       MOV     DPTR,#(AXD_epDesc + 3)
   \   00003F   74..         MOV     A,#(AXD_SimpleDesc & 0xff)
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   74..         MOV     A,#((AXD_SimpleDesc >> 8) & 0xff)
   \   000045   F0           MOVX    @DPTR,A
    198            AXD_epDesc.latencyReq = noLatencyReqs;
   \   000046   7400         MOV     A,#0x0
   \   000048   90....       MOV     DPTR,#(AXD_epDesc + 5)
   \   00004B   F0           MOVX    @DPTR,A
    199          
    200            // Register the endpoint description with the AF
    201            afRegister( &AXD_epDesc );
   \   00004C                ; Setup parameters for call to function afRegister
   \   00004C   7A..         MOV     R2,#(AXD_epDesc & 0xff)
   \   00004E   7B..         MOV     R3,#((AXD_epDesc >> 8) & 0xff)
   \   000050   12....       LCALL   ??afRegister?relay
    202          
    203            // Register for all key events - This app will handle all key events
    204            RegisterForKeys( AXD_TaskID );
   \   000053                ; Setup parameters for call to function RegisterForKeys
   \   000053   90....       MOV     DPTR,#AXD_TaskID
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F9           MOV     R1,A
   \   000058   12....       LCALL   ??RegisterForKeys?relay
    205          
    206            // Update the display
    207          #if defined ( LCD_SUPPORTED )
    208              HalLcdWriteString( "AXD", HAL_LCD_LINE_1 );
   \   00005B                ; Setup parameters for call to function HalLcdWriteString
   \   00005B   7900         MOV     R1,#0x0
   \   00005D   7A..         MOV     R2,#(`?<Constant "AXD">` & 0xff)
   \   00005F   7B..         MOV     R3,#((`?<Constant "AXD">` >> 8) & 0xff)
   \   000061   12....       LCALL   ??HalLcdWriteString?relay
    209          #endif
    210          
    211            ZDO_RegisterForZDOMsg( AXD_TaskID, End_Device_Bind_rsp );
   \   000064                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000064   7A20         MOV     R2,#0x20
   \   000066   7B80         MOV     R3,#-0x80
   \   000068   90....       MOV     DPTR,#AXD_TaskID
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   F9           MOV     R1,A
   \   00006D   12....       LCALL   ??ZDO_RegisterForZDOMsg?relay
    212            ZDO_RegisterForZDOMsg( AXD_TaskID, Match_Desc_rsp );
   \   000070                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000070   7A06         MOV     R2,#0x6
   \   000072   7B80         MOV     R3,#-0x80
   \   000074   90....       MOV     DPTR,#AXD_TaskID
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F9           MOV     R1,A
   \   000079   12....       LCALL   ??ZDO_RegisterForZDOMsg?relay
    213            
    214            //下面是用户自定义的初始化
    215          
    216            Init_ADXL345();
   \   00007C                ; Setup parameters for call to function Init_ADXL345
   \   00007C   12....       LCALL   ??Init_ADXL345?relay
    217            
    218          }
   \   00007F   7F01         MOV     R7,#0x1
   \   000081   02....       LJMP    ?BANKED_LEAVE_XDATA
    219          
    220          /*********************************************************************
    221           * @fn      AXD_ProcessEvent
    222           *
    223           * @brief   Generic Application Task event processor.  This function
    224           *          is called to process all events for the task.  Events
    225           *          include timers, messages and any other user defined events.
    226           *
    227           * @param   task_id  - The OSAL assigned task ID.
    228           * @param   events - events to process.  This is a bit map and can
    229           *                   contain more than one event.
    230           *
    231           * @return  none
    232           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    233          UINT16 AXD_ProcessEvent( byte task_id, UINT16 events )
   \                     AXD_ProcessEvent:
    234          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   C0E0         PUSH    A
   \   00000D   7401         MOV     A,#0x1
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   D0E0         POP     A
   \   000014   F0           MOVX    @DPTR,A
   \   000015   EA           MOV     A,R2
   \   000016   FE           MOV     R6,A
   \   000017   EB           MOV     A,R3
   \   000018   FF           MOV     R7,A
    235            afIncomingMSGPacket_t *MSGpkt;
    236          //  osal_event_hdr_t *pMsg;
    237            afDataConfirm_t *afDataConfirm;
    238          
    239            // Data Confirmation message fields
    240            byte sentEP;
    241            ZStatus_t sentStatus;
    242            byte sentTransID;       // This should match the value sent
    243          
    244            if ( events & SYS_EVENT_MSG )
   \   000019   7400         MOV     A,#0x0
   \   00001B   5E           ANL     A,R6
   \   00001C   F8           MOV     R0,A
   \   00001D   7480         MOV     A,#-0x80
   \   00001F   5F           ANL     A,R7
   \   000020   F9           MOV     R1,A
   \   000021   7400         MOV     A,#0x0
   \   000023   68           XRL     A,R0
   \   000024   7003         JNZ     ??AXD_ProcessEvent_0
   \   000026   7400         MOV     A,#0x0
   \   000028   69           XRL     A,R1
   \                     ??AXD_ProcessEvent_0:
   \   000029   7003         JNZ     $+5
   \   00002B   02....       LJMP    ??AXD_ProcessEvent_1 & 0xFFFF
    245            {
    246              MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( AXD_TaskID );
   \   00002E                ; Setup parameters for call to function osal_msg_receive
   \   00002E   90....       MOV     DPTR,#AXD_TaskID
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F9           MOV     R1,A
   \   000033   12....       LCALL   ??osal_msg_receive?relay
   \   000036   8A..         MOV     ?V0 + 4,R2
   \   000038   8B..         MOV     ?V0 + 5,R3
   \   00003A   85....       MOV     ?V0 + 0,?V0 + 4
   \   00003D   85....       MOV     ?V0 + 1,?V0 + 5
    247              while ( MSGpkt )
   \                     ??AXD_ProcessEvent_2:
   \   000040   E5..         MOV     A,?V0 + 0
   \   000042   6400         XRL     A,#0x0
   \   000044   7004         JNZ     ??AXD_ProcessEvent_3
   \   000046   E5..         MOV     A,?V0 + 1
   \   000048   6400         XRL     A,#0x0
   \                     ??AXD_ProcessEvent_3:
   \   00004A   7003         JNZ     $+5
   \   00004C   02....       LJMP    ??AXD_ProcessEvent_4 & 0xFFFF
    248              {
    249                switch ( MSGpkt->hdr.event )
   \   00004F   85..82       MOV     DPL,?V0 + 0
   \   000052   85..83       MOV     DPH,?V0 + 1
   \   000055   E0           MOVX    A,@DPTR
   \   000056   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for AXD_ProcessEvent>_0`:
   \   000059   00           DB        0
   \   00005A   04           DB        4
   \   00005B   C0           DB        192
   \   00005C   ....         DW        ??AXD_ProcessEvent_5
   \   00005E   D1           DB        209
   \   00005F   ....         DW        ??AXD_ProcessEvent_6
   \   000061   D3           DB        211
   \   000062   ....         DW        ??AXD_ProcessEvent_7
   \   000064   FD           DB        253
   \   000065   ....         DW        ??AXD_ProcessEvent_8
   \   000067   ....         DW        ??AXD_ProcessEvent_9
    250                {
    251                  case ZDO_CB_MSG:
    252                    AXD_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );
   \                     ??AXD_ProcessEvent_7:
   \   000069                ; Setup parameters for call to function AXD_ProcessZDOMsgs
   \   000069   AA..         MOV     R2,?V0 + 0
   \   00006B   AB..         MOV     R3,?V0 + 1
   \   00006D   12....       LCALL   ??AXD_ProcessZDOMsgs?relay
   \   000070   8066         SJMP    ??AXD_ProcessEvent_9
    253                    break;
    254          
    255                  case KEY_CHANGE:
    256                    AXD_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
   \                     ??AXD_ProcessEvent_5:
   \   000072                ; Setup parameters for call to function AXD_HandleKeys
   \   000072   85..82       MOV     DPL,?V0 + 0
   \   000075   85..83       MOV     DPH,?V0 + 1
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   FA           MOV     R2,A
   \   00007D   85..82       MOV     DPL,?V0 + 0
   \   000080   85..83       MOV     DPH,?V0 + 1
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   F9           MOV     R1,A
   \   000087   12....       LCALL   ??AXD_HandleKeys?relay
   \   00008A   804C         SJMP    ??AXD_ProcessEvent_9
    257                    break;
    258          
    259                  case AF_DATA_CONFIRM_CMD:
    260                    // This message is received as a confirmation of a data packet sent.
    261                    // The status is of ZStatus_t type [defined in ZComDef.h]
    262                    // The message fields are defined in AF.h
    263                    afDataConfirm = (afDataConfirm_t *)MSGpkt;
   \                     ??AXD_ProcessEvent_8:
   \   00008C   85....       MOV     ?V0 + 2,?V0 + 0
   \   00008F   85....       MOV     ?V0 + 3,?V0 + 1
    264                    sentEP = afDataConfirm->endpoint;
   \   000092   85..82       MOV     DPL,?V0 + 2
   \   000095   85..83       MOV     DPH,?V0 + 3
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   85..82       MOV     DPL,?XSP + 0
   \   00009E   85..83       MOV     DPH,?XSP + 1
   \   0000A1   F0           MOVX    @DPTR,A
    265                    sentStatus = afDataConfirm->hdr.status;
    266                    sentTransID = afDataConfirm->transID;
    267                    (void)sentEP;
    268                    (void)sentTransID;
    269          
    270                    // Action taken when confirmation is received.
    271                    if ( sentStatus != ZSuccess )
   \   0000A2   8034         SJMP    ??AXD_ProcessEvent_9
    272                    {
    273                      // The data wasn't delivered -- Do something
    274                    }
    275                    break;
    276          
    277                  case AF_INCOMING_MSG_CMD:
    278              //      MSGpkt = (afIncomingMSGPacket_t *) pMsg;
    279          #ifdef AXD_COR
    280                    AXD_ReceiveDataIndication( MSGpkt->srcAddr.addr.shortAddr, MSGpkt->clusterId,
    281                                              MSGpkt->cmd.DataLength, MSGpkt->cmd.Data);
    282                    //AXD_MessageMSGCB( MSGpkt );
    283          #endif
    284                    break;
    285          
    286                  case ZDO_STATE_CHANGE:
    287                    AXD_NwkState = (devStates_t)(MSGpkt->hdr.status);
   \                     ??AXD_ProcessEvent_6:
   \   0000A4   85..82       MOV     DPL,?V0 + 0
   \   0000A7   85..83       MOV     DPH,?V0 + 1
   \   0000AA   A3           INC     DPTR
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   90....       MOV     DPTR,#AXD_NwkState
   \   0000AF   F0           MOVX    @DPTR,A
    288                    if ( (AXD_NwkState == DEV_ZB_COORD)
    289                        || (AXD_NwkState == DEV_ROUTER)
    290                        || (AXD_NwkState == DEV_END_DEVICE) )
   \   0000B0   90....       MOV     DPTR,#AXD_NwkState
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   6409         XRL     A,#0x9
   \   0000B6   6010         JZ      ??AXD_ProcessEvent_10
   \   0000B8   90....       MOV     DPTR,#AXD_NwkState
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   6407         XRL     A,#0x7
   \   0000BE   6008         JZ      ??AXD_ProcessEvent_10
   \   0000C0   90....       MOV     DPTR,#AXD_NwkState
   \   0000C3   E0           MOVX    A,@DPTR
   \   0000C4   6406         XRL     A,#0x6
   \   0000C6   7010         JNZ     ??AXD_ProcessEvent_9
    291                    {
    292                      // Start sending "the" message in a regular interval.
    293                      osal_start_timerEx( AXD_TaskID,
    294                                          AXD_SEND_MSG_EVT,
    295                                          AXD_SEND_MSG_TIMEOUT );
   \                     ??AXD_ProcessEvent_10:
   \   0000C8                ; Setup parameters for call to function osal_start_timerEx
   \   0000C8   7C88         MOV     R4,#-0x78
   \   0000CA   7D13         MOV     R5,#0x13
   \   0000CC   7A01         MOV     R2,#0x1
   \   0000CE   7B00         MOV     R3,#0x0
   \   0000D0   90....       MOV     DPTR,#AXD_TaskID
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   F9           MOV     R1,A
   \   0000D5   12....       LCALL   ??osal_start_timerEx?relay
    296                    }
    297                    break;
    298          
    299                  default:
    300                    break;
    301                }
    302          
    303                // Release the memory
    304                osal_msg_deallocate( (uint8 *)MSGpkt );
   \                     ??AXD_ProcessEvent_9:
   \   0000D8                ; Setup parameters for call to function osal_msg_deallocate
   \   0000D8   AA..         MOV     R2,?V0 + 0
   \   0000DA   AB..         MOV     R3,?V0 + 1
   \   0000DC   12....       LCALL   ??osal_msg_deallocate?relay
    305          
    306                // Next
    307                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( AXD_TaskID );
   \   0000DF                ; Setup parameters for call to function osal_msg_receive
   \   0000DF   90....       MOV     DPTR,#AXD_TaskID
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   F9           MOV     R1,A
   \   0000E4   12....       LCALL   ??osal_msg_receive?relay
   \   0000E7   8A..         MOV     ?V0 + 4,R2
   \   0000E9   8B..         MOV     ?V0 + 5,R3
   \   0000EB   85....       MOV     ?V0 + 0,?V0 + 4
   \   0000EE   85....       MOV     ?V0 + 1,?V0 + 5
   \   0000F1   02....       LJMP    ??AXD_ProcessEvent_2 & 0xFFFF
    308              }
    309          
    310              // return unprocessed events
    311              return (events ^ SYS_EVENT_MSG);
   \                     ??AXD_ProcessEvent_4:
   \   0000F4   7400         MOV     A,#0x0
   \   0000F6   6E           XRL     A,R6
   \   0000F7   FA           MOV     R2,A
   \   0000F8   7480         MOV     A,#-0x80
   \   0000FA   6F           XRL     A,R7
   \   0000FB   FB           MOV     R3,A
   \   0000FC   8039         SJMP    ??AXD_ProcessEvent_11
    312            }
    313          
    314            // Send a message out - This event is generated by a timer
    315            //  (setup in AXD_Init()).
    316            if ( events & AXD_SEND_MSG_EVT )
   \                     ??AXD_ProcessEvent_1:
   \   0000FE   EE           MOV     A,R6
   \   0000FF   A2E0         MOV     C,0xE0 /* A   */.0
   \   000101   5024         JNC     ??AXD_ProcessEvent_12
    317            {
    318              // Send "the" message
    319            //  HalLcdWriteString( "SampleApp", HAL_LCD_LINE_1 );
    320              zb_HandleOsalEvent(events);
   \   000103                ; Setup parameters for call to function zb_HandleOsalEvent
   \   000103   EE           MOV     A,R6
   \   000104   FA           MOV     R2,A
   \   000105   EF           MOV     A,R7
   \   000106   FB           MOV     R3,A
   \   000107   12....       LCALL   ??zb_HandleOsalEvent?relay
    321              AXD_SendTheMessage();
   \   00010A                ; Setup parameters for call to function AXD_SendTheMessage
   \   00010A   12....       LCALL   ??AXD_SendTheMessage?relay
    322          
    323              // Setup to send message again
    324              osal_start_timerEx( AXD_TaskID,
    325                                  AXD_SEND_MSG_EVT,
    326                                  (AXD_SEND_MSG_TIMEOUT/5) );
   \   00010D                ; Setup parameters for call to function osal_start_timerEx
   \   00010D   7CE8         MOV     R4,#-0x18
   \   00010F   7D03         MOV     R5,#0x3
   \   000111   7A01         MOV     R2,#0x1
   \   000113   7B00         MOV     R3,#0x0
   \   000115   90....       MOV     DPTR,#AXD_TaskID
   \   000118   E0           MOVX    A,@DPTR
   \   000119   F9           MOV     R1,A
   \   00011A   12....       LCALL   ??osal_start_timerEx?relay
    327          
    328              // return unprocessed events
    329              return (events ^ AXD_SEND_MSG_EVT);
   \   00011D   7401         MOV     A,#0x1
   \   00011F   6E           XRL     A,R6
   \   000120   FA           MOV     R2,A
   \   000121   7400         MOV     A,#0x0
   \   000123   6F           XRL     A,R7
   \   000124   FB           MOV     R3,A
   \   000125   8010         SJMP    ??AXD_ProcessEvent_11
    330            }
    331              if ( events & ( ZB_USER_EVENTS ) )
   \                     ??AXD_ProcessEvent_12:
   \   000127   EE           MOV     A,R6
   \   000128   54FF         ANL     A,#0xff
   \   00012A   6007         JZ      ??AXD_ProcessEvent_13
    332            {
    333              // User events are passed to the application
    334              zb_HandleOsalEvent( events );
   \   00012C                ; Setup parameters for call to function zb_HandleOsalEvent
   \   00012C   EE           MOV     A,R6
   \   00012D   FA           MOV     R2,A
   \   00012E   EF           MOV     A,R7
   \   00012F   FB           MOV     R3,A
   \   000130   12....       LCALL   ??zb_HandleOsalEvent?relay
    335          
    336              // Do not return here, return 0 later
    337            }
    338          
    339            // Discard unknown events
    340            return 0;
   \                     ??AXD_ProcessEvent_13:
   \   000133   7A00         MOV     R2,#0x0
   \   000135   7B00         MOV     R3,#0x0
   \                     ??AXD_ProcessEvent_11:
   \   000137   7402         MOV     A,#0x2
   \   000139   12....       LCALL   ?DEALLOC_XSTACK8
   \   00013C   7F08         MOV     R7,#0x8
   \   00013E   02....       LJMP    ?BANKED_LEAVE_XDATA
    341          }
    342          
    343          /*********************************************************************
    344           * Event Generation Functions
    345           */
    346          /*********************************************************************
    347           * @fn      AXD_ProcessZDOMsgs()
    348           *
    349           * @brief   Process response messages
    350           *
    351           * @param   none
    352           *
    353           * @return  none
    354           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    355          void AXD_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg )
   \                     AXD_ProcessZDOMsgs:
    356          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    357            switch ( inMsg->clusterID )
   \   000009   E5..         MOV     A,?V0 + 0
   \   00000B   240C         ADD     A,#0xc
   \   00000D   F582         MOV     DPL,A
   \   00000F   E5..         MOV     A,?V0 + 1
   \   000011   3400         ADDC    A,#0x0
   \   000013   F583         MOV     DPH,A
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F5..         MOV     ?V0 + 2,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 3,A
   \   00001C   78..         MOV     R0,#?V0 + 2
   \   00001E   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for AXD_ProcessZDOMsgs>_0`:
   \   000021   0000         DW        0
   \   000023   0200         DW        2
   \   000025   0680         DW        32774
   \   000027   ....         DW        ??AXD_ProcessZDOMsgs_0
   \   000029   2080         DW        32800
   \   00002B   ....         DW        ??AXD_ProcessZDOMsgs_1
   \   00002D   ....         DW        ??AXD_ProcessZDOMsgs_2
    358            {
    359              case End_Device_Bind_rsp:
    360                if ( ZDO_ParseBindRsp( inMsg ) == ZSuccess )
   \                     ??AXD_ProcessZDOMsgs_1:
   \   00002F   E5..         MOV     A,?V0 + 0
   \   000031   2411         ADD     A,#0x11
   \   000033   F582         MOV     DPL,A
   \   000035   E5..         MOV     A,?V0 + 1
   \   000037   3400         ADDC    A,#0x0
   \   000039   F583         MOV     DPH,A
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F8           MOV     R0,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F583         MOV     DPH,A
   \   000041   8882         MOV     DPL,R0
   \   000043   E0           MOVX    A,@DPTR
   \   000044   7009         JNZ     ??AXD_ProcessZDOMsgs_3
    361                {
    362                  // Light LED
    363                  HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   000046                ; Setup parameters for call to function HalLedSet
   \   000046   7A01         MOV     R2,#0x1
   \   000048   7908         MOV     R1,#0x8
   \   00004A   12....       LCALL   ??HalLedSet?relay
   \   00004D   8066         SJMP    ??AXD_ProcessZDOMsgs_2
    364                }
    365          #if defined(BLINK_LEDS)
    366                else
    367                {
    368                  // Flash LED to show failure
    369                  HalLedSet ( HAL_LED_4, HAL_LED_MODE_FLASH );
   \                     ??AXD_ProcessZDOMsgs_3:
   \   00004F                ; Setup parameters for call to function HalLedSet
   \   00004F   7A04         MOV     R2,#0x4
   \   000051   7908         MOV     R1,#0x8
   \   000053   12....       LCALL   ??HalLedSet?relay
   \   000056   805D         SJMP    ??AXD_ProcessZDOMsgs_2
    370                }
    371          #endif
    372                break;
    373          
    374              case Match_Desc_rsp:
    375                {
    376                  ZDO_ActiveEndpointRsp_t *pRsp = ZDO_ParseEPListRsp( inMsg );
   \                     ??AXD_ProcessZDOMsgs_0:
   \   000058                ; Setup parameters for call to function ZDO_ParseEPListRsp
   \   000058   AA..         MOV     R2,?V0 + 0
   \   00005A   AB..         MOV     R3,?V0 + 1
   \   00005C   12....       LCALL   ??ZDO_ParseEPListRsp?relay
   \   00005F   8A..         MOV     ?V0 + 2,R2
   \   000061   8B..         MOV     ?V0 + 3,R3
   \   000063   AE..         MOV     R6,?V0 + 2
   \   000065   AF..         MOV     R7,?V0 + 3
    377                  if ( pRsp )
   \   000067   EE           MOV     A,R6
   \   000068   6400         XRL     A,#0x0
   \   00006A   7003         JNZ     ??AXD_ProcessZDOMsgs_4
   \   00006C   EF           MOV     A,R7
   \   00006D   6400         XRL     A,#0x0
   \                     ??AXD_ProcessZDOMsgs_4:
   \   00006F   6044         JZ      ??AXD_ProcessZDOMsgs_2
    378                  {
    379                    if ( pRsp->status == ZSuccess && pRsp->cnt )
   \   000071   8E82         MOV     DPL,R6
   \   000073   8F83         MOV     DPH,R7
   \   000075   E0           MOVX    A,@DPTR
   \   000076   7036         JNZ     ??AXD_ProcessZDOMsgs_5
   \   000078   8E82         MOV     DPL,R6
   \   00007A   8F83         MOV     DPH,R7
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   602C         JZ      ??AXD_ProcessZDOMsgs_5
    380                    {
    381                      AXD_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000082   7402         MOV     A,#0x2
   \   000084   90....       MOV     DPTR,#(AXD_DstAddr + 2)
   \   000087   F0           MOVX    @DPTR,A
    382                      AXD_DstAddr.addr.shortAddr = pRsp->nwkAddr;
   \   000088   8E82         MOV     DPL,R6
   \   00008A   8F83         MOV     DPH,R7
   \   00008C   A3           INC     DPTR
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   F8           MOV     R0,A
   \   00008F   A3           INC     DPTR
   \   000090   E0           MOVX    A,@DPTR
   \   000091   F9           MOV     R1,A
   \   000092   90....       MOV     DPTR,#AXD_DstAddr
   \   000095   E8           MOV     A,R0
   \   000096   F0           MOVX    @DPTR,A
   \   000097   A3           INC     DPTR
   \   000098   E9           MOV     A,R1
   \   000099   F0           MOVX    @DPTR,A
    383                      // Take the first endpoint, Can be changed to search through endpoints
    384                      AXD_DstAddr.endPoint = pRsp->epList[0];
   \   00009A   8E82         MOV     DPL,R6
   \   00009C   8F83         MOV     DPH,R7
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   90....       MOV     DPTR,#(AXD_DstAddr + 3)
   \   0000A6   F0           MOVX    @DPTR,A
    385          
    386                      // Light LED
    387                      HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   0000A7                ; Setup parameters for call to function HalLedSet
   \   0000A7   7A01         MOV     R2,#0x1
   \   0000A9   7908         MOV     R1,#0x8
   \   0000AB   12....       LCALL   ??HalLedSet?relay
    388                    }
    389                    osal_mem_free( pRsp );
   \                     ??AXD_ProcessZDOMsgs_5:
   \   0000AE                ; Setup parameters for call to function osal_mem_free
   \   0000AE   EE           MOV     A,R6
   \   0000AF   FA           MOV     R2,A
   \   0000B0   EF           MOV     A,R7
   \   0000B1   FB           MOV     R3,A
   \   0000B2   12....       LCALL   ??osal_mem_free?relay
    390                  }
    391                }
    392                break;
    393            }
    394          }
   \                     ??AXD_ProcessZDOMsgs_2:
   \   0000B5   7F04         MOV     R7,#0x4
   \   0000B7   02....       LJMP    ?BANKED_LEAVE_XDATA
    395          
    396          /*********************************************************************
    397           * @fn      AXD_HandleKeys
    398           *
    399           * @brief   Handles all key events for this device.
    400           *
    401           * @param   shift - true if in shift/alt.
    402           * @param   keys - bit field for key events. Valid entries:
    403           *                 HAL_KEY_SW_4
    404           *                 HAL_KEY_SW_3
    405           *                 HAL_KEY_SW_2
    406           *                 HAL_KEY_SW_1
    407           *
    408           * @return  none
    409           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    410          void AXD_HandleKeys( byte shift, byte keys )
   \                     AXD_HandleKeys:
    411          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EA           MOV     A,R2
   \   00000D   FF           MOV     R7,A
    412            zAddrType_t dstAddr;
    413          
    414            // Shift is used to make each button/switch dual purpose.
    415            if ( shift )
   \   00000E   EE           MOV     A,R6
   \   00000F   6003         JZ      $+5
   \   000011   02....       LJMP    ??AXD_HandleKeys_0 & 0xFFFF
    416            {
    417              if ( keys & HAL_KEY_SW_1 )
    418              {
    419              }
    420              if ( keys & HAL_KEY_SW_2 )
    421              {
    422              }
    423              if ( keys & HAL_KEY_SW_3 )
    424              {
    425              }
    426              if ( keys & HAL_KEY_SW_4 )
    427              {
    428              }
    429            }
    430            else
    431            {
    432              if ( keys & HAL_KEY_SW_1 )
    433              {
    434              }
    435          
    436              if ( keys & HAL_KEY_SW_2 )
   \   000014   EF           MOV     A,R7
   \   000015   A2E1         MOV     C,0xE0 /* A   */.1
   \   000017   507A         JNC     ??AXD_HandleKeys_1
    437              {
    438                HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \   000019                ; Setup parameters for call to function HalLedSet
   \   000019   7A00         MOV     R2,#0x0
   \   00001B   7908         MOV     R1,#0x8
   \   00001D   12....       LCALL   ??HalLedSet?relay
    439          
    440                // Initiate an End Device Bind Request for the mandatory endpoint
    441                dstAddr.addrMode = Addr16Bit;
   \   000020   7402         MOV     A,#0x2
   \   000022   C0E0         PUSH    A
   \   000024   7408         MOV     A,#0x8
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   D0E0         POP     A
   \   00002B   F0           MOVX    @DPTR,A
    442                dstAddr.addr.shortAddr = 0x0000; // Coordinator
   \   00002C   85..82       MOV     DPL,?XSP + 0
   \   00002F   85..83       MOV     DPH,?XSP + 1
   \   000032   7400         MOV     A,#0x0
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   7400         MOV     A,#0x0
   \   000038   F0           MOVX    @DPTR,A
    443                ZDP_EndDeviceBindReq( &dstAddr, NLME_GetShortAddr(),
    444                                      AXD_epDesc.endPoint,
    445                                      AXD_PROFID,
    446                                      AXD_MAX_CLUSTERS, (cId_t *)AXD_ClusterList,
    447                                      AXD_MAX_CLUSTERS, (cId_t *)AXD_ClusterList,
    448                                      FALSE );
   \   000039                ; Setup parameters for call to function NLME_GetShortAddr
   \   000039   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00003C   8A..         MOV     ?V0 + 0,R2
   \   00003E   8B..         MOV     ?V0 + 1,R3
   \   000040   AC..         MOV     R4,?V0 + 0
   \   000042   AD..         MOV     R5,?V0 + 1
   \   000044                ; Setup parameters for call to function ZDP_EndDeviceBindReq
   \   000044   75..00       MOV     ?V0 + 0,#0x0
   \   000047   78..         MOV     R0,#?V0 + 0
   \   000049   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004C   75....       MOV     ?V0 + 0,#(AXD_ClusterList & 0xff)
   \   00004F   75....       MOV     ?V0 + 1,#((AXD_ClusterList >> 8) & 0xff)
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000057   75..01       MOV     ?V0 + 0,#0x1
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005F   75....       MOV     ?V0 + 0,#(AXD_ClusterList & 0xff)
   \   000062   75....       MOV     ?V0 + 1,#((AXD_ClusterList >> 8) & 0xff)
   \   000065   78..         MOV     R0,#?V0 + 0
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006A   75..01       MOV     ?V0 + 0,#0x1
   \   00006D   78..         MOV     R0,#?V0 + 0
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000072   75..04       MOV     ?V0 + 0,#0x4
   \   000075   75..0F       MOV     ?V0 + 1,#0xf
   \   000078   78..         MOV     R0,#?V0 + 0
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007D   90....       MOV     DPTR,#AXD_epDesc
   \   000080   E0           MOVX    A,@DPTR
   \   000081   F9           MOV     R1,A
   \   000082   7409         MOV     A,#0x9
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   AA82         MOV     R2,DPL
   \   000089   AB83         MOV     R3,DPH
   \   00008B   12....       LCALL   ??ZDP_EndDeviceBindReq?relay
   \   00008E   7409         MOV     A,#0x9
   \   000090   12....       LCALL   ?DEALLOC_XSTACK8
    449              }
    450          
    451              if ( keys & HAL_KEY_SW_3 )
    452              {
    453              }
    454          
    455              if ( keys & HAL_KEY_SW_4 )
   \                     ??AXD_HandleKeys_1:
   \   000093   EF           MOV     A,R7
   \   000094   A2E3         MOV     C,0xE0 /* A   */.3
   \   000096   5068         JNC     ??AXD_HandleKeys_0
    456              {
    457                HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \   000098                ; Setup parameters for call to function HalLedSet
   \   000098   7A00         MOV     R2,#0x0
   \   00009A   7908         MOV     R1,#0x8
   \   00009C   12....       LCALL   ??HalLedSet?relay
    458          
    459                // Initiate a Match Description Request (Service Discovery)
    460                dstAddr.addrMode = AddrBroadcast;
   \   00009F   740F         MOV     A,#0xf
   \   0000A1   C0E0         PUSH    A
   \   0000A3   7408         MOV     A,#0x8
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   D0E0         POP     A
   \   0000AA   F0           MOVX    @DPTR,A
    461                dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
   \   0000AB   85..82       MOV     DPL,?XSP + 0
   \   0000AE   85..83       MOV     DPH,?XSP + 1
   \   0000B1   74FF         MOV     A,#-0x1
   \   0000B3   F0           MOVX    @DPTR,A
   \   0000B4   A3           INC     DPTR
   \   0000B5   74FF         MOV     A,#-0x1
   \   0000B7   F0           MOVX    @DPTR,A
    462                ZDP_MatchDescReq( &dstAddr, NWK_BROADCAST_SHORTADDR,
    463                                  AXD_PROFID,
    464                                  AXD_MAX_CLUSTERS, (cId_t *)AXD_ClusterList,
    465                                  AXD_MAX_CLUSTERS, (cId_t *)AXD_ClusterList,
    466                                  FALSE );
   \   0000B8                ; Setup parameters for call to function ZDP_MatchDescReq
   \   0000B8   75..00       MOV     ?V0 + 0,#0x0
   \   0000BB   78..         MOV     R0,#?V0 + 0
   \   0000BD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C0   75....       MOV     ?V0 + 0,#(AXD_ClusterList & 0xff)
   \   0000C3   75....       MOV     ?V0 + 1,#((AXD_ClusterList >> 8) & 0xff)
   \   0000C6   78..         MOV     R0,#?V0 + 0
   \   0000C8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CB   75..01       MOV     ?V0 + 0,#0x1
   \   0000CE   78..         MOV     R0,#?V0 + 0
   \   0000D0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D3   75....       MOV     ?V0 + 0,#(AXD_ClusterList & 0xff)
   \   0000D6   75....       MOV     ?V0 + 1,#((AXD_ClusterList >> 8) & 0xff)
   \   0000D9   78..         MOV     R0,#?V0 + 0
   \   0000DB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DE   75..04       MOV     ?V0 + 0,#0x4
   \   0000E1   75..0F       MOV     ?V0 + 1,#0xf
   \   0000E4   78..         MOV     R0,#?V0 + 0
   \   0000E6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E9   7901         MOV     R1,#0x1
   \   0000EB   7CFF         MOV     R4,#-0x1
   \   0000ED   7DFF         MOV     R5,#-0x1
   \   0000EF   7408         MOV     A,#0x8
   \   0000F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F4   AA82         MOV     R2,DPL
   \   0000F6   AB83         MOV     R3,DPH
   \   0000F8   12....       LCALL   ??ZDP_MatchDescReq?relay
   \   0000FB   7408         MOV     A,#0x8
   \   0000FD   12....       LCALL   ?DEALLOC_XSTACK8
    467              }
    468            }
    469          }
   \                     ??AXD_HandleKeys_0:
   \   000100   7409         MOV     A,#0x9
   \   000102   12....       LCALL   ?DEALLOC_XSTACK8
   \   000105   7F02         MOV     R7,#0x2
   \   000107   02....       LJMP    ?BANKED_LEAVE_XDATA
    470          
    471          /*********************************************************************
    472           * LOCAL FUNCTIONS
    473           */
    474          
    475          /*********************************************************************
    476           * @fn      AXD_MessageMSGCB
    477           *
    478           * @brief   Data message processor callback.  This function processes
    479           *          any incoming data - probably from other devices.  So, based
    480           *          on cluster ID, perform the intended action.
    481           *
    482           * @param   none
    483           *
    484           * @return  none
    485           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    486          void AXD_MessageMSGCB( afIncomingMSGPacket_t *pkt )
   \                     AXD_MessageMSGCB:
    487          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    488            switch ( pkt->clusterId )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F5..         MOV     ?V0 + 0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018   78..         MOV     R0,#?V0 + 0
   \   00001A   12....       LCALL   ?US_SWITCH_DENSE
   \                     `?<Jumptable for AXD_MessageMSGCB>_0`:
   \   00001D   0100         DW        1
   \   00001F   00           DB        0
   \   000020   ....         DW        ??AXD_MessageMSGCB_0
   \   000022   ....         DW        ??AXD_MessageMSGCB_1
    489            {
    490              case AXD_CLUSTERID:
    491                // "the" message
    492          #if defined( LCD_SUPPORTED )
    493                HalLcdWriteScreen( (char*)pkt->cmd.Data, "rcvd" );
   \                     ??AXD_MessageMSGCB_1:
   \   000024                ; Setup parameters for call to function HalLcdWriteScreen
   \   000024   7C..         MOV     R4,#(`?<Constant "rcvd">` & 0xff)
   \   000026   7D..         MOV     R5,#((`?<Constant "rcvd">` >> 8) & 0xff)
   \   000028   EE           MOV     A,R6
   \   000029   2415         ADD     A,#0x15
   \   00002B   F582         MOV     DPL,A
   \   00002D   EF           MOV     A,R7
   \   00002E   3400         ADDC    A,#0x0
   \   000030   F583         MOV     DPH,A
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FA           MOV     R2,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FB           MOV     R3,A
   \   000037   12....       LCALL   ??HalLcdWriteScreen?relay
    494          #elif defined( WIN32 )
    495                WPRINTSTR( pkt->cmd.Data );
    496          #endif
    497                break;
    498            }
    499          }
   \                     ??AXD_MessageMSGCB_0:
   \   00003A   7F02         MOV     R7,#0x2
   \   00003C   02....       LJMP    ?BANKED_LEAVE_XDATA
    500          
    501          /*********************************************************************
    502           * @fn      AXD_SendTheMessage
    503           *
    504           * @brief   Send "the" message.
    505           *
    506           * @param   none
    507           *
    508           * @return  none
    509           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    510          void AXD_SendTheMessage( void )
   \                     AXD_SendTheMessage:
    511          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    512          //  char theMessageData[] = "Hello World";
    513          #ifdef AXD_END
    514          //  int i;
    515          
    516          //  for(i=0;i<8;i++)
    517          //  {
    518          //    TEMP[i]++;
    519          //  }
    520          
    521            Multiple_Read_ADXL345();
   \   000005                ; Setup parameters for call to function Multiple_Read_ADXL345
   \   000005   12....       LCALL   ??Multiple_Read_ADXL345?relay
    522           // displayXYZ(BUFFER);
    523          
    524            if ( AF_DataRequest( &AXD_DstAddr, &AXD_epDesc,
    525                                 AXD_CLUSTERID,
    526                                 (byte)(sizeof(BUFFER)),
    527                                 (byte *)(BUFFER),
    528                                 &AXD_TransID,
    529                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   \   000008                ; Setup parameters for call to function AF_DataRequest
   \   000008   75..0A       MOV     ?V0 + 0,#0xa
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000010   75....       MOV     ?V0 + 0,#(AXD_TransID & 0xff)
   \   000013   75....       MOV     ?V0 + 1,#((AXD_TransID >> 8) & 0xff)
   \   000016   78..         MOV     R0,#?V0 + 0
   \   000018   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001B   75....       MOV     ?V0 + 0,#(BUFFER & 0xff)
   \   00001E   75....       MOV     ?V0 + 1,#((BUFFER >> 8) & 0xff)
   \   000021   78..         MOV     R0,#?V0 + 0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   75..08       MOV     ?V0 + 0,#0x8
   \   000029   75..00       MOV     ?V0 + 1,#0x0
   \   00002C   78..         MOV     R0,#?V0 + 0
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   75..01       MOV     ?V0 + 0,#0x1
   \   000034   75..00       MOV     ?V0 + 1,#0x0
   \   000037   78..         MOV     R0,#?V0 + 0
   \   000039   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003C   7920         MOV     R1,#0x20
   \   00003E   7C..         MOV     R4,#(AXD_epDesc & 0xff)
   \   000040   7D..         MOV     R5,#((AXD_epDesc >> 8) & 0xff)
   \   000042   7A..         MOV     R2,#(AXD_DstAddr & 0xff)
   \   000044   7B..         MOV     R3,#((AXD_DstAddr >> 8) & 0xff)
   \   000046   12....       LCALL   ??AF_DataRequest?relay
   \   000049   7409         MOV     A,#0x9
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
    530            {
    531              // Successfully requested to be sent.
    532            }
    533            else
    534            {
    535              // Error occurred in request to send.
    536            }
    537          #endif
    538          }
   \   00004E   7F02         MOV     R7,#0x2
   \   000050   02....       LJMP    ?BANKED_LEAVE_XDATA
    539          
    540          /*********************************************************************
    541          *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    542          void AXD_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
   \                     AXD_ReceiveDataIndication:
    543          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   740E         MOV     A,#0xe
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 2,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 3,A
   \   000019   7410         MOV     A,#0x10
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F5..         MOV     ?V0 + 4,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 5,A
    544          #if defined ( MT_SAPI_CB_FUNC )
    545            /* First check if MT has subscribed for this callback. If so , pass it as
    546            a event to MonitorTest and return control to calling function after that */
    547            if ( SAPICB_CHECK( SPI_CB_SAPI_RCV_DATA_IND ) )
    548            {
    549              zb_MTCallbackReceiveDataIndication( source, command, len, pData  );
    550            }
    551            else
    552          #endif  //MT_SAPI_CB_FUNC
    553            {
    554              zb_ReceiveDataIndication( source, command, len, pData  );
   \   000025                ; Setup parameters for call to function zb_ReceiveDataIndication
   \   000025   78..         MOV     R0,#?V0 + 4
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   78..         MOV     R0,#?V0 + 2
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002F   EE           MOV     A,R6
   \   000030   FC           MOV     R4,A
   \   000031   EF           MOV     A,R7
   \   000032   FD           MOV     R5,A
   \   000033   AA..         MOV     R2,?V0 + 0
   \   000035   AB..         MOV     R3,?V0 + 1
   \   000037   12....       LCALL   ??zb_ReceiveDataIndication?relay
   \   00003A   7404         MOV     A,#0x4
   \   00003C   12....       LCALL   ?DEALLOC_XSTACK8
    555            }
    556          }
   \   00003F   7F06         MOV     R7,#0x6
   \   000041   02....       LJMP    ?BANKED_LEAVE_XDATA
    557          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    558          void zb_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
   \                     zb_ReceiveDataIndication:
    559          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   7410         MOV     A,#0x10
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F5..         MOV     ?V0 + 0,A
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 1,A
    560          //  uint8 buf[8];
    561            displayXYZ(pData);
                              ^
Warning[Pe167]: argument of type "uint8 *" is incompatible with parameter of
          type "char *"
   \   000011                ; Setup parameters for call to function displayXYZ
   \   000011   AA..         MOV     R2,?V0 + 0
   \   000013   AB..         MOV     R3,?V0 + 1
   \   000015   12....       LCALL   ??displayXYZ?relay
    562          
    563              
    564          }
   \   000018   7F06         MOV     R7,#0x6
   \   00001A   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "AXD">>`:
   \   000000   41584400     DB "AXD"

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "rcvd">>`:
   \   000000   72637664     DB "rcvd"
   \            00      

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for AXD_ClusterList>`:
   \   000000   0100         DW 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for AXD_SimpleDesc>`:
   \   000000   0A           DB 10
   \   000001   040F0100     DW 3844, 1
   \   000005   0001         DB 0, 1
   \   000007   ....         DW AXD_ClusterList
   \   000009   01           DB 1
   \   00000A   ....         DW AXD_ClusterList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_ProcessEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_ProcessEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_ProcessZDOMsgs?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_ProcessZDOMsgs

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_HandleKeys?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_MessageMSGCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_MessageMSGCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_SendTheMessage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_SendTheMessage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??AXD_ReceiveDataIndication?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    AXD_ReceiveDataIndication

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zb_ReceiveDataIndication?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_ReceiveDataIndication

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "AXD">`:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for <Constant "AXD">>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "rcvd">`:
   \   000000                DS 5
   \   000005                REQUIRE `?<Initializer for <Constant "rcvd">>`
   \   000005                REQUIRE __INIT_XDATA_I

   Maximum stack usage in bytes:

     Function                      ISTACK PSTACK XSTACK
     --------                      ------ ------ ------
     AXD_HandleKeys                    1      0     46
       -> HalLedSet                    0      0     38
       -> NLME_GetShortAddr            0      0     38
       -> ZDP_EndDeviceBindReq         0      0     56
       -> HalLedSet                    0      0     38
       -> ZDP_MatchDescReq             0      0     54
     AXD_Init                          0      0      9
       -> afRegister                   0      0     18
       -> RegisterForKeys              0      0     18
       -> HalLcdWriteString            0      0     18
       -> ZDO_RegisterForZDOMsg        0      0     18
       -> ZDO_RegisterForZDOMsg        0      0     18
       -> Init_ADXL345                 0      0     18
     AXD_MessageMSGCB                  0      0     10
       -> HalLcdWriteScreen            0      0     20
     AXD_ProcessEvent                  1      0     18
       -> osal_msg_receive             0      0     36
       -> AXD_ProcessZDOMsgs           0      0     36
       -> AXD_HandleKeys               0      0     36
       -> osal_start_timerEx           0      0     36
       -> osal_msg_deallocate          0      0     36
       -> osal_msg_receive             0      0     36
       -> zb_HandleOsalEvent           0      0     36
       -> AXD_SendTheMessage           0      0     36
       -> osal_start_timerEx           0      0     36
       -> zb_HandleOsalEvent           0      0     36
     AXD_ProcessZDOMsgs                0      0     30
       -> HalLedSet                    0      0     24
       -> HalLedSet                    0      0     24
       -> ZDO_ParseEPListRsp           0      0     24
       -> HalLedSet                    0      0     24
       -> osal_mem_free                0      0     24
     AXD_ReceiveDataIndication         0      0     22
       -> zb_ReceiveDataIndication     0      0     36
     AXD_SendTheMessage                0      0     37
       -> Multiple_Read_ADXL345        0      0     20
       -> AF_DataRequest               0      0     38
     zb_ReceiveDataIndication          0      0     32
       -> displayXYZ                   0      0     28


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     AXD_ClusterList                   2
     AXD_SimpleDesc                   12
     AXD_epDesc                        6
     AXD_TaskID                        1
     AXD_NwkState                      1
     AXD_TransID                       1
     AXD_DstAddr                       4
     AXD_Init                        132
     AXD_ProcessEvent                321
     AXD_ProcessZDOMsgs              186
     AXD_HandleKeys                  266
     AXD_MessageMSGCB                 63
     AXD_SendTheMessage               83
     AXD_ReceiveDataIndication        68
     zb_ReceiveDataIndication         29
     ?<Initializer for <Constant "AXD">>
                                       4
     ?<Initializer for <Constant "rcvd">>
                                       5
     ?<Initializer for AXD_ClusterList>
                                       2
     ?<Initializer for AXD_SimpleDesc>
                                      12
     ??AXD_Init?relay                  6
     ??AXD_ProcessEvent?relay          6
     ??AXD_ProcessZDOMsgs?relay        6
     ??AXD_HandleKeys?relay            6
     ??AXD_MessageMSGCB?relay          6
     ??AXD_SendTheMessage?relay        6
     ??AXD_ReceiveDataIndication?relay
                                       6
     ??zb_ReceiveDataIndication?relay
                                       6
     ?<Constant "AXD">                 4
     ?<Constant "rcvd">                5

 
 1 148 bytes in segment BANKED_CODE
    48 bytes in segment BANK_RELAYS
    23 bytes in segment XDATA_I
    23 bytes in segment XDATA_ID
    13 bytes in segment XDATA_Z
 
 1 219 bytes of CODE  memory
    36 bytes of XDATA memory

Errors: none
Warnings: 1
